/*******************************************************************************
 * Copyright 2012 The Infinit.e Open Source Project
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
package com.ikanow.infinit.e.data_model.api.knowledge;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.List;

import org.bson.types.ObjectId;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;
import com.ikanow.infinit.e.data_model.api.BaseApiPojo;

//
// Generated by clients to make requests to the API (SearchResource/SearchController)
//

public class AdvancedQueryPojo extends BaseApiPojo {

	static public class QueryTermPojo 
	{
		// Can only specify 1 of: ftext [+metadataField], etext [+metadataField], {entity,entityValue+entityType} [+sentiment], { event, assoc } [+sentiment], time, geo
		
		public String ftext; // Free text query (arbitrary Lucene query)
		public String etext; // Exact text search
		public String metadataField = null; // Restricts an etext/ftext to apply only to the specified metadata field
		// Ignored for other query types.
		
		public String entity; // Entity index ("disambiguous_name/type", '/' can be ':')
		// Alternative for entity (overrides it):
		public String entityValue; // (must be specified)
		public String entityType; // (can be left unspecified)
		
		static public class EntityOptionPojo { // Options for "entity" types
			public boolean rawText = false; // If true (!default) adds the disambiguated name and all aliases as an exact text search
			public boolean expandAlias = false; // If true (!default), adds other actual names to the search
			public boolean expandOntology = false; // If true (!default), adds "useful" generalizations of the entity to the search (CURRENTLY UNSUPPORTED)
		}
		public EntityOptionPojo entityOpt;
		
		static public class AssociationTermPojo { // All these terms are ANDed together
			public QueryTermPojo entity1; // obviously only etext/ftext/entity/(entityValue,entityType) make sense
			public QueryTermPojo entity2; // obviously only etext/ftext/entity/(entityValue,entityType) make sense
			public String verb; // verb or verb category
			public QueryTermPojo.GeoTermPojo geo;
			public QueryTermPojo.TimeTermPojo time;
			public String type; // Event,Fact,Summary
		}
		public AssociationTermPojo event; //DEPRECATED - use assoc instead, this is just for backwards compatibility
		public AssociationTermPojo assoc;
		
		//This sentiment tag is ignored unless accompanied with an entity or assoc term:
		static public class SentimentModifierPojo {
			public Double min;
			public Double max;
		}
		public SentimentModifierPojo sentiment;
		
		static public class TimeTermPojo { // Time bounding term for the query
			public String min; // Min date, inclusive, (default - no min) - any sensible date format parsed
			public String max; // Max date, inclusive, (default - no max) - any sensible date format parsed
		}
		public TimeTermPojo time;
		
		static public class GeoTermPojo { // Geo bounding term for the query
			//1 of these
			public String centerll; // The center of the bounding box, "(lat,lng)" or "lat,lng" format			
				//OR
			public String name; //name of some geolocation e.g. new jersey, united states (NOT SUPPORTED YET)
				//OR
			public String polys; //list of polygon lat/lng points (NOT SUPPORTED YET)			
			//REQUIRED for these (maybe, i dont think we need dist for polys or some name (e.g. countries)
			public String dist; // The radius of the circle enclosing the bounding box, "Nu" where N is the distance, and u is the unit, from {mi,km,nm}, default km
			
			//OR can be this for bounding box
			public String minll; // Top-left (same format as above)
			public String maxll; // Bottom-right
			
			//OPTIONAL for all
				//e.g. send countrysubsidiary and we will only search states, cities, points (not country so US doesnt show up 1mil times)
			public String ontology_type; //the ontology type of the searchterm so we can only search this type an below 
		}
		public GeoTermPojo geo;		
	}
	public List<QueryTermPojo> qt; // Array of query terms as above
	public String logic; // The logic to combine these query terms, use Lucene logic with qt[n], n=0,1,2,... or n=1,2,3...
	public Boolean expandAlias; // Optional, defaults to true - if false, manually specified aliases are ignored (automatic aliases still depend on per-entity settings)
	public Boolean explain; // Optional, defaults to false - if true appends the "explain" parameter from elasticsearch to every promoted document 
	
	static public class QueryRawPojo { // Raw query object for power users
		public QueryRawPojo() {}
		public QueryRawPojo(String s) { query = s; }
		public String query; // (ElasticSearch too complex to be written into an object so just pass it through)
		
		static public class Deserializer implements JsonDeserializer<QueryRawPojo> {
			public QueryRawPojo deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
			throws JsonParseException {
				return new QueryRawPojo(json.toString());
			}
		}
	}
	public QueryRawPojo raw; // Allows an ElasticSearch raw query (raw instead of query as the root object), note this overrides the qt/logic parameters
	
	static public class QueryInputPojo { // Input parameters for the query
		public String name; // If specified, the saved dataset name
		public List<String> tags; // If specified, an ORd list of tags that need to be in a source for it to be added to the query
		
		static public class TypeAndTagTermPojo { // If specified, an ORd list of types (each type ANDed with an ORd list of tags)
			public String type; // The type (eg news, social) - must be specified
			public List<String> tags; // An optional list of tags ANDed with the above type (must be forced to lower case)
		}
		public List<TypeAndTagTermPojo> typeAndTags;
		
		public List<String> sources; // A list of sources to include/exclude depending on the "src_include" tag
		public Boolean srcInclude; // Defaults to true - whether the sources are to be included (true) or excluded (false)
	}
	public QueryInputPojo input; // (optional, searches over the entire system group DB if left out)
	
	static public class QueryScorePojo { // Scoring parameters for the query
		public Integer numAnalyze = 1000; // The number of documents on which to perform processing, default 1000
		
		public Double sigWeight = 0.67; // The relative weight to give to query significance (Infinit.e score), default to 0.67
		public Double relWeight = 0.33; // The relative weight to give to search relevance (standard Lucene score), default to 0.33
		public HashMap<String, Double> sourceWeights; // highest priority score weightings
		public HashMap<String, Double> typeWeights; // middle priority score weightings
		public HashMap<String, Double> tagWeights; // low priority score weightings
		
		public Boolean scoreEnts = true; // Whether to include significance scores with entities (allows more efficient doc retrieval when ranked by date/rel)
		public Boolean adjustAggregateSig; // if true (default automatic) then relevance is used to adjust significance scores for aggregations
		
		static public class TimeProxTermPojo { // Scoring based on time
			public String time = "now"; // The "centre" time, any sensible format is parsed, including "now" (default)
			public String decay = "1m"; // The decay parameter, used as 1/(1 + (t-t0)/decay) ... ie after time decay the score is x'd by 0.5, default "1m" 
				// time format "Nu" with N the quantity and u the unit, one of {d,w,m,y}
			public transient long nTime; // (time as a long - for internal calcs)
			public transient double dInvDecay; //(1/decay in ms - for internal calcs)
		}
		public TimeProxTermPojo timeProx; // (optional, not applied if left out)
		
		static public class GeoProxTermPojo { // Scoring based on location
			public String ll; // The "centre" location, format "(lat,lng)" or "lat,lng"
			public String decay; // The decay distance used like TimeProxTermPojo, "Nu" format as discussed above in GeoTermPojo.dist
		}
		public GeoProxTermPojo geoProx; // (optional, not applied if left out)
	}
	public QueryScorePojo score; // (optional, just returns the most recent "numReturn" docs if left out)
	
	static public class QueryOutputPojo {
		public String format = "json"; // output format: "xml", "json" (default), "rss" ("xml" and "json" are the same fields in different formats, "rss" only includes the URL)
		static public class DocumentOutputPojo {
			public Boolean enable = true; // (bring back documents if true)
			public Boolean eventsTimeline = false; // (bring back just the events, not the documents)
			public Integer numReturn = 100; // (number of documents to bring back)
			public Integer numEventsTimelineReturn = 1000; // (number of events to bring back)
			public Integer skip = 0;
			public Boolean ents = true;
			public Boolean geo = null; // (by default do whatever "ents" does)
			public Boolean events = true;
			public Boolean facts = true;
			public Boolean summaries = true;
			public Boolean metadata = true;
		}
		public DocumentOutputPojo docs = new DocumentOutputPojo();
		
		static public class AggregationOutputPojo {
			// Geo-spatial/temporal aggregation
			// (A more powerful interface to do the same thing is listed below)
			public Integer geoNumReturn = 0; // (100 works, 1000 is probably best if you can wait for it)
			public String timesInterval = null; // "month", or "<N>[ydwh]" (disabled if null)
			
			// Different built-in aggregation types, the number of records to return, format { "term", "count" }
			// (A more powerful interface to the same thing is listed below)
			public Integer entsNumReturn = 0;
			public Integer eventsNumReturn = 0;
			public Integer factsNumReturn  = 0;
			public Integer sources = 0; // (src urls)
			public Integer sourceMetadata = 0; // (both tags and types)
			
			// Temporal aggregation (basic info)
			static public class TemporalAggregationOutputPojo {
				public String timesInterval = null; // "month", or "<N>[ydwh]" (if null, takes from timesInterval - errors out if neither set)
				public List<String> entityList; // List of entities to grab
				//TODO (INF-955): NOT IMPLEMENTED YET
				public Boolean entityCountOnly = null; // If true counts only (default); if false then provides sentiment (if available), significance and total counts  
				public Integer geoCount = null; // Number of geo-counts to store per time, 0/null to not display at all			
			};
			public TemporalAggregationOutputPojo moments = null;
			
			// Alternatively:
			public String raw = null; // (allows the user to specify his own facets in ElasticSearch syntax as an alternative)
		}
		public AggregationOutputPojo aggregation = null; // (off by default)
		
		// Output filters (entity types, assoc verb categories)
		static public class FilterOutputPojo {
			public String[] entityTypes = null;
			public String[] assocVerbs = null;
		}
		public FilterOutputPojo filter = null; // (off by default)
		
	}
	public QueryOutputPojo output; // (optional, just defaults to the above defaults if omitted)
	public List<ObjectId> communityIds = null; // (optional - can be used to store everything about a query in one object - eg for saved queries)
}
