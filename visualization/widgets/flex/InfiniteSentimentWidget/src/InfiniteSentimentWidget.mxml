<?xml version="1.0" encoding="utf-8"?>
<!--
   Copyright 2012, The Infinit.e Open Source Project

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->
<components:WidgetModule xmlns:fx="http://ns.adobe.com/mxml/2009"
	xmlns:actionscript="actionscript.*"
	xmlns:components="com.ikanow.infinit.e.widget.library.components.*"
	xmlns:ilog="http://www.ilog.com/2007/ilog/flex"
	xmlns:s="library://ns.adobe.com/flex/spark"
	xmlns:mx="library://ns.adobe.com/flex/mx"
	implements="com.ikanow.infinit.e.widget.library.widget.IWidget"
	currentState="nodata"
	creationComplete="{ try { onWidgetCreationComplete(event); } catch (e:Error) {  } dispatchEvent(new Event('Done Loading')); }">

	<components:states>
		<s:State name="dataview" />
		<s:State name="nodata" />
	</components:states>

	<fx:Style source="/com/ikanow/infinit/e/assets/styles/infiniteStyles.css" />

	<fx:Style>
		@namespace s "library://ns.adobe.com/flex/spark";
		@namespace mx "library://ns.adobe.com/flex/mx";
		/* If you need to override a style in our stylesheet, or add another
		style that we did not support you can do so here, an example has been commented out
		Please see documentation about over-riding MX component styles to display fonts*/
		/*
		mx|Text
		{
		font-family: infiniteNonCFFFont;
		}
		*/
	</fx:Style>
	<fx:Script>
		<![CDATA[
			import com.ikanow.infinit.e.widget.library.data.SelectedInstance;
			import com.ikanow.infinit.e.widget.library.data.SelectedItem;
			import com.ikanow.infinit.e.widget.library.data.WidgetDragObject;
			import com.ikanow.infinit.e.widget.library.enums.FilterDataSetEnum;
			import com.ikanow.infinit.e.widget.library.framework.InfiniteMaster;
			import com.ikanow.infinit.e.widget.library.framework.WidgetSaveObject;
			import com.ikanow.infinit.e.widget.library.frameworkold.ModuleInterface;
			import com.ikanow.infinit.e.widget.library.frameworkold.QueryResults;
			import com.ikanow.infinit.e.widget.library.utility.JSONEncoder;
			import com.ikanow.infinit.e.widget.library.utility.WidgetDragUtil;
			import com.ikanow.infinit.e.widget.library.utility.XmlEncoder;
			import com.ikanow.infinit.e.widget.library.widget.IWidget;
			import com.ikanow.infinit.e.widget.library.widget.IWidgetContext;
			
			import flexlib.mdi.containers.MDIWindow;
			
			import ilog.charts3d.series.ColumnSeries3D;
			import ilog.charts3d.series.items.ColumnSeries3DItem;
			
			import mx.charts.ChartItem;
			import mx.charts.HitData;
			import mx.charts.chartClasses.Series;
			import mx.charts.effects.SeriesEffect;
			import mx.charts.events.ChartItemEvent;
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.core.DragSource;
			import mx.core.UITextField;
			import mx.events.FlexEvent;
			import mx.managers.CursorManager;
			import mx.managers.DragManager;
			
			import org.alivepdf.pdf.PDF;
			
			import skins.InfiniteFilterApplyOrIgnore;
			
			import spark.events.IndexChangeEvent;
			
			import system.data.Collection;
			import system.data.Iterator;
			import system.data.Map;
			import system.data.Set;
			import system.data.maps.HashMap;
			import system.data.sets.HashSet;
			
			private static const SORT_BY_SIGNIFICANCE:int = 0;
			
			private static const SORT_BY_QUERY_COVERAGE:int = 1;
			
			private static const SORT_BY_AVERAGE_FREQUENCY:int = 2;
			
			private static const SORT_BY_POSITIVE_SENTIMENT:int = 3;
			
			private static const SORT_BY_NEGATIVE_SENTIMENT:int = 4;
			
			private static const SORT_BY_POSITIVE_AGGREGATE_SENTIMENT:int = 5;
			
			private static const SORT_BY_NEGATIVE_AGGREGATE_SENTIMENT:int = 6;
			
			[Bindable]
			private var showEffect:SeriesInterpolate = interpolateIn;
			
			private var queryData:ArrayCollection = new ArrayCollection();
			
			private var queryData_entities:ArrayCollection = null;
			
			private var currData:ArrayCollection = new ArrayCollection();
			
			private var currData_entities:ArrayCollection = new ArrayCollection();
			
			private var filterEntities:HashSet = null;
			
			private var _hasData:Boolean = false;
			
			[Bindable]
			private var allEntities:Array = [];
			private var entitiesOnDisplay:Map = new HashMap();
			private var maxSig:Number = 0;
			
			[Bindable]
			private var topEntitiesCombo:ArrayCollection;
			
			private var hasFilter:Boolean = false;
			
			// Determines if filtering results are immediately applied:
			private var ignoreLocalFilter:Boolean = false;
			
			private var _context:IWidgetContext;
			
			private var internalFilterUpdate:Boolean = false;
			
			// Handle the regex changing (just create a timer to avoid it happening too often)
			
			//(some horrible hackery)
			private var _filterModifyTimer:Timer = new Timer( 300, 1 ); // (runs once after 250ms)
			
			private var _regexFilter:RegExp = null;
			
			[Bindable]
			private var _regexActivateString:String = "";
			
			/**
			 * function to change the data to show the next feeds entities
			 *
			 * @param event The Event received when the sliders value is changed
			 */
			
			private var entSliderOffset:int = 0;
			
			/**
			 * object that is used to manage the widget options on 
			 * save and on load
			 */
			private var widgetOptions:Object = new Object();
			private var sigSliderApplied:Boolean = false;
			private var queryHash:String = "";
			
			/**
			 * function to build a pdf version of the widget
			 *
			 * @return pdf version of the widget
			 */
			public function generatePdf( printPDF:PDF, title:String ):PDF
			{
				return null; //screenshot widget (default)
			}
			
			/**
			 * function to broadcast if the module has data so it doesn't repass data to itself
			 * when new modules are being loaded with data on first load up
			 *
			 * @return If the module has data
			 */
			public function hasData():Boolean
			{
				//return true if data is already present
				return _hasData;
			}
			
			/**
			 * Allow users to export the widget contents in the specified format
			 * @format filename: the filename+path to which the data will be written (in case it needs to be embedded)
			 * @param format: the format from the "supportedFormats" call
			 *
			 * @returns a ByteArray containing the data to output
			 */
			
			public function onGenerateExportData( filename:String, format:String ):ByteArray
			{
				// Has to be CSV
				
				// Some preamble:
				// number of matches: _context.getQuery_AllResults().getQuerySetSize()
				// the query: _context.getLastQuery()
				
				var csv:String = new String();
				var communityIds:String = "*";
				var lastQuery:Object = _context.getLastQuery();
				if (null != lastQuery.communityIds)
				{
					communityIds = "";
					for each (var commId:String in lastQuery.communityIds) {
						if (communityIds.length > 0)
							communityIds+=",";
						communityIds += commId;
					}
				}
				lastQuery.communityIds = null;
				
				function csvEscape():String {
					return escape(arguments[1]);					
				}
				function csvSanitize( toEscape: String ):String
				{
					if (null == toEscape)
						return '""';
					return '"' + toEscape.replace(/(["])/g,"\\$1").replace(/[\r\n]/g, ' ') + '"';
				}
				
				csv += '#Total_hits=,' + _context.getQuery_AllResults().getQuerySetSize() + '\r\n';
				csv += '#query=,/api/knowledge/document/query/'+communityIds+'?json=' + JSONEncoder.encode(lastQuery).replace(/([,&#\r\n])/g, csvEscape ) + '\r\n'; 
				csv += '#"entity_name","entity_type","entity_dimension",query_coverage,query_significance,query_avg_frequency,doc_count,total_frequency,sentiment_count,sentiment_positive,sentiment_negative\r\n';
				
				for each (var ent:Object in this.currData_entities)
				{
					if ( ( null != ent.sentimentCount ) && ( ent.sentimentCount > 0 ) )
					{
						if ( (null == _regexFilter) || _regexFilter.test( ent.disambiguated_name + " ( " + ent.type + " ) " + ent.dimension ) )
						{
							csv += csvSanitize(ent.disambiguated_name); 						
							csv += ',' + csvSanitize(ent.type);
							csv += ',' + csvSanitize(ent.dimension);
							csv += ',' + ent.queryCoverage;
							csv += ',' + ent.datasetSignificance;
							csv += ',' + ent.averageFreq;
							csv += ',' + ent.doccount;
							csv += ',' + ent.totalfrequency;
							if (null != ent.sentimentCount)
								csv += ',' + ent.sentimentCount;
							else 
								csv += ',0';
							if (null != ent.positiveSentiment)
								csv += ',' + ent.positiveSentiment;
							else 
								csv += ',0.0';
							if (null != ent.negativeSentiment)
								csv += ',' + ent.negativeSentiment;
							else 
								csv += ',0.0';
							csv += '\r\n';							
						}
					}
				}				
				var ba:ByteArray = new ByteArray();
				ba.writeUTFBytes( csv );
				return ba;
			}			
			
			/**
			 * This function gets called when the user clicks to output
			 * data to a PDF. Return null if custom PDF generation is
			 * not desired.
			 *
			 * @return a new alivePdf Page containing the converted data
			 */
			public function onGeneratePDF( printPDF:PDF, title:String ):PDF
			{
				return null;
			}
			
			/**
			 * IWidget interface to receive data object (IWidgetContext).
			 * Store the iwidgetcontext so we can receieve data later.
			 */
			public function onInit( context:IWidgetContext ):void
			{
				_context = context;
			}
			
			/**
			 * If a save object has been saved from 'onSaveWidgetOptions' then
			 * when the app gets reloaded the last save string
			 * will be passed to this function.
			 *
			 * @param widgetOptions the last save object or null if there was none
			 */
			public function onLoadWidgetOptions( widgetOptions:WidgetSaveObject ):void
			{
				if( widgetOptions != null )
				{
					//this holds a users last map 
					if ( widgetOptions.userSave != null )
					{
						this.widgetOptions = widgetOptions.userSave;
						// (note this is apparently persisted
						
						// (In all 3 cases below - apply changes if onReceiveNewQuery called, else don't)
						
						// Slider (only apply if query hash hasn't changed)						
						this.queryHash = this.getQueryHash();
						
						if ( (null == queryHash) // Don't have a query yet
							||
							( ( null != this.widgetOptions.queryHash ) && ( this.widgetOptions.queryHash == this.queryHash) ) )
						{
							if ( ( null != sigSlider ) && ( null != this.widgetOptions.sigSliderValue ) )
							{
								sigSlider.value = this.widgetOptions.sigSliderValue;
								entitySliderUpdate( null );
							}//TESTED
							else
							{
								this.entSliderOffset = this.widgetOptions.sigSliderValue;
								sigSliderApplied = true;
								this.queryHash = this.widgetOptions.queryHash;
							}//TESTED
						}
						else // ensure reset to 0
						{
							this.entSliderOffset = 0;
							sigSliderApplied = true;
						}//TESTED
						
						
						// Sorting
						if( ( null != sortOptions.dataProvider) && ( null != this.widgetOptions.sortOptionIndex ) ) 
						{
							sortOptions.selectedIndex = this.widgetOptions.sortOptionIndex;
							if ( null != sigSlider ) // (else onReceiveNewQuery not called yet)
							{
								sortOptions_changeHandler( null );
							}
						}//TESTED
						
						// Regex
						if ( ( null != regexFilter ) && (null != this.widgetOptions.regexFilter ) )
						{
							regexFilter.text = this.widgetOptions.regexFilter;
							doneChangingFilter( null );
						}//TESTED
						
					}//(end widget save non null)
				}//(end widget options non null)
			}
			
			protected function widgetheaderdragimage1_mouseDownHandler(event:MouseEvent):void
			{
				var docs:Array = new Array();
				if (0 == chart.selectedChartItems.length)
				{
					for each ( var doc:Object in topEntitiesCombo )
					{					
						docs.push(doc.entity);
					}
				}
				else 
				{
					var temp:ArrayCollection = getSelectedIndexes();
					for each ( var chartIndex:int in temp )
					{
						doc = this.topEntitiesCombo.getItemAt(chartIndex);
						docs.push(doc.entity);
					}
				}
				var dragObject:WidgetDragObject = new WidgetDragObject();
				dragObject.entities = new ArrayCollection(docs);
				
				var ds:DragSource = new DragSource();
				ds.addData(dragObject, WidgetDragUtil.WIDGET_DRAG_FORMAT );
				
				DragManager.doDrag(dragImage, ds, event);
			}
			
			/**
			 * function to rescale the component when the parent container is being resized
			 *
			 * @param newHeight The new height the component needs to be set to
			 * @param newWidth The new width the component needs to be set to
			 */
			public function onParentResize( newHeight:Number, newWidth:Number ):void
			{
				this.height = newHeight;
				this.width = newWidth;
			}
			
			/**
			 * IWidget interface that fires when a new filter is done (including from ourself)
			 * We can access the data fromt he filter by using our
			 * iwidgetcontext object _context.getQuery_FilteredResults().getTopDocuments();
			 */
			public function onReceiveNewFilter():void
			{
				if ( !internalFilterUpdate )
				{
					hasFilter = true;
					setTimeout( resetIgnoreLocalFilter, 1000 );
				}
				
				this.currData = _context.getQuery_FilteredResults().getTopDocuments();
				this.currData_entities = _context.getQuery_FilteredResults().getEntities();

				populateGraph();
				this.entSliderOffset = 0;// (if filtering always reset the slider)
				this.sigSlider.value = 0;
				renderGraph();				
			}
			
			/**
			 * IWidget interface that fires when a new query is done.
			 * We can access the data from the query by using our
			 * iwidgetcontext object context.getQuery_TopResults().getTopDocuments();
			 */
			public function onReceiveNewQuery():void
			{
				if ( !internalFilterUpdate )
				{
					hasFilter = false;
					setTimeout( resetIgnoreLocalFilter, 1000 );
				}
				this.currentState = "dataview"; // (initializes everything)
				
				if ( null == sigSlider )
				{ // may not be initialized yet?
					return;
				}
				
				this.currData = _context.getQuery_AllResults().getTopDocuments();
				this.currData_entities = _context.getQuery_AllResults().getEntities(true);
				
				populateGraph();
				if (sigSliderApplied)
				{	
					this.sigSlider.value = this.entSliderOffset;
					entitySliderUpdate(null);	// (calls renderGraph)
					sigSliderApplied = false;
				}
				else // (if the same query is being repeated then can leave the slider as is)
				{
					var newQueryHash:String = this.getQueryHash();
					
					if (this.queryHash != newQueryHash)
					{
						this.queryHash = newQueryHash;
						this.entSliderOffset = 0;
						this.sigSlider.value = 0;
					}//TESTED			
					renderGraph();
				}//TESTED
			}
			
			/**
			 * This function gets called when the workspace is being saved.
			 * return null if no save object is needed.
			 *
			 * @return an object this widget can use to reload state
			 */
			public function onSaveWidgetOptions():Object
			{
				if ( null == sigSlider ) // (nothing initialized yet)
				{
					return widgetOptions;
				}
				//set the values for the widget
				widgetOptions.sortOptionIndex = sortOptions.selectedIndex;
				widgetOptions.regexFilter = regexFilter.text;
				widgetOptions.sigSliderValue = (sigSlider != null) ? sigSlider.value : 0;
				widgetOptions.queryHash = this.queryHash;
				
				return widgetOptions;
			}
			
			private function getQueryHash():String
			{
				var x:Object = _context.getLastQuery();
				var y:Object = null;
				if ( null == x ) // (don't have a "last query" yet
					return null;
				
				if ( null != x["communityIds"] ) // ensure they're in the right order
				{
					var tmpCommIds:Array = x["communityIds"] as Array;
					tmpCommIds.sort();
				}
				var hash:String = XmlEncoder.encode(x).toXMLString();
				
				return hash;
			}
			
			/**
			 * function to receive events from the parent and other modules
			 *
			 * @param event The Event received
			 */
			public function receiveEvent( event:Event ):void
			{
			}
			
			/**
			 * @returns A list of supported formats, displayed in a context menu in the format
			 * "Export <string>" - these are called with "generateExportData"
			 * Note this doesn't cover the "built-in" Alive PDF export.
			 * However if the developer specifies PDF and generatePdf() returns non-null then this will be used.
			 */
			
			public function supportedExportFormats():ArrayCollection
			{
				var ac:ArrayCollection = new ArrayCollection();
				ac.addItem( "csv" );
				return ac;
			}
			
			protected function addDocumentsToFilter_internal( entName:String, sentiment:int, docids:Set, docmap:Map, dir:int ):void
			{
				var docs:ArrayCollection = new ArrayCollection();
				var currMaxVal:Number = -100; 
				
				// All documents matching the entity (needs to have its performance improved)
				for each ( var feed:Object in this.currData )
				{
					for each ( var entities:Object in feed.entities )
					{
						if ( ( entities.index.toString() == entName ) && entities.hasOwnProperty("sentiment") )
						{
							var currVal:Number = entities.sentiment;
							if ( ( 0 == sentiment ) && ( dir < 0 ) )
								currVal = -currVal;							
									
							var add:Boolean = false;
							if ( 100 == sentiment )
							{
								add = true;
							}
							else if ( ( sentiment == -1 ) && ( currVal < 0.0 ) )
							{
								add = true;
							}
							if ( ( sentiment == 1 ) && ( currVal > 0.0 ) )
							{
								add = true;
							}
							else if ( ( 0 == sentiment ) && ( currVal >= 0 ) )
							{
								if ( currVal >= currMaxVal )
								{
									if ( currVal > currMaxVal ) // oops, new max
									{
										docids.clear();
										docs.removeAll();
									}
									add = true;
								}								
							}
							if ( add )
							{
								currMaxVal = currVal;
								docids.add( feed._id.toString() );
								docs.addItem(feed);								
							}
							
						}
					}
				}// pass 1, get the docs
				
				//pass 2, get the entities
				for each ( var doc:Object in docs )
				{
					var entSet:Set = new HashSet();
					
					for each ( var ent:Object in doc.entities )
					{
						entSet.add( ent.index.toString() );
					}
					docmap.put( doc._id.toString(), entSet );					
				}								
			}
			protected function addDocumentsToFilter( entName:String, sentiment:int ):void
			{
				var docids:Set = new HashSet();
				var docmap:Map = new HashMap();
				
				addDocumentsToFilter_internal(entName, sentiment, docids, docmap, 1);
				if (0 == sentiment)
				{
					var docids2:Set = new HashSet();
					var docmap2:Map = new HashMap();
					addDocumentsToFilter_internal(entName, sentiment, docids2, docmap2, -1);
					for each ( var doc:Object in docids2.toArray() )
					{
						docids.add(doc);
						var ents2:Object = docmap2.get(doc);
						if ( null != ents2 )
						{
							docmap.put(doc, ents2);
						}
					}
				}
				if ( docids.isEmpty() )
				{
					if ( -1 == sentiment ) 
						this.send2Query_internal(entName, true, false, 0.0, true, -1e-7);
					else if (1 == sentiment)
						this.send2Query_internal(entName, true, true, 1e-7, false, 0.0);
					else if (0 == sentiment)
						this.send2Query_internal(entName, true);
					else
						this.send2Query_internal(entName);

					return;
				}
				
				var desc:String = "Doc Filter: ";
				
				if ( 100 == sentiment )
				{
					desc += "Any Containing " + entName + " (and sentiment)";
				}
				else if ( 1 == sentiment )
				{
					desc += "Any Containing " + entName + " (and positive sentiment)";
				}
				else if ( -1 == sentiment )
				{
					desc += "Any Containing " + entName + " (and negative sentiment)";
				}
				else
				{
					desc += "Max Positive and Negative Sentiment Containing " + entName;
				}
				_context.filterByDocFieldAndEntities( FilterDataSetEnum.FILTER_GLOBAL_DATA, docids, docmap, "_id", "_id", desc );
			}
			
			/**
			 * function to handle when the chart legend is clicked on
			 *
			 * @param event The MouseEvent received when the chart legend is clicked on
			 */
			protected function chart_doubleClickHandler( event:MouseEvent ):void
			{
				var entName:String = "";
				
				//make sure an entity was clicked
				if ( event.target is UITextField )
				{
					entName = event.target.text;

					var ent:Object = entitiesOnDisplay.get(entName);
					if ( ( null == ent ) || ( null == ent.entity ) )
					{
						return;								
					}
					else if ( ent.entity.hasOwnProperty("notPromoted") )
					{
						this.send2Query_internal(ent.entity.index, true);								
					}
					else
					{
						addDocumentsToFilter( ent.entity.index, 100 );
					}							
				}
			}
			protected function chart_itemClickHandler( event:mx.charts.events.ChartItemEvent ):void
			{
				var data:HitData = event.hitData;
				var item:ColumnSeries3DItem = ColumnSeries3DItem( event.hitData.chartItem );
				
				var entName:String = data.item.entity.index;
				var sentiment:int = 0;
				
				var isPromoted:Boolean = !data.item.entity.hasOwnProperty("notPromoted");
				if ( !isPromoted )
				{
					if ( item.yValue == data.item.positiveSentiment )
					{
						this.send2Query_internal(entName, true, true, 1e-7, false, 0.0);
					}
					else if ( item.yValue == data.item.negativeSentiment )
					{
						this.send2Query_internal(entName, true, false, 0.0, true, -1e-7);
					}
					else if ( item.yValue == data.item.aggregateSentiment )
					{
						send2Query_internal(entName, true);
					}
					else
					{
						send2Query_internal(entName);
					}
					return;
				}				
				
				if ( item.yValue == data.item.positiveSentiment )
				{
					sentiment = 1;
					addDocumentsToFilter( entName, sentiment );
				}
				else if ( item.yValue == data.item.negativeSentiment )
				{
					sentiment = -1;
					addDocumentsToFilter( entName, sentiment );
				}
				else if ( item.yValue == data.item.aggregateSentiment )
				{
					addDocumentsToFilter( entName, sentiment );
				}
				else
				{
					addDocumentsToFilter( entName, 100 );
				}
			}
			
			protected function chart_mouseOver( event:MouseEvent ):void
			{
				if ( event.target is UITextField )
				{
					var textfield:UITextField = UITextField( event.target );
					var str:String = event.target.text;
					
					if ( str.length > 0 )
					{
						if ( ( str.length < 3 ) && ( ( '-' == str.charAt(0) ) ||  ( 0x30 == ( str.charCodeAt( 0 ) & 0xF0 ) ) ) )
						{
							// One of the axis, ignore
							textfield.toolTip = "(Axis)";
						}
						else
						{
							var ent:Object = entitiesOnDisplay.get(str);
							if ( ( null == ent ) || ( null == ent.entity ) )
							{
								textfield.toolTip = "(Axis)";								
							}
							else if ( ent.entity.hasOwnProperty("notPromoted") )
							{
								textfield.toolTip = str + "\n[Double Click: add entity to query]";								
							}
							else
							{
								textfield.toolTip = str + "\n[Double Click: add documents with sentiment for this entity to filter]";								
							}							
						}
					}
				}
			}
			protected function entitySliderUpdate( event:Event ):void
			{
				if ( sigSlider.value < 0 )
				{
					sigSlider.value = 0;
				}
				
				if ( sigSlider.value > sigSlider.maximum )
				{
					sigSlider.value = sigSlider.maximum;
				}
				this.entSliderOffset = this.sigSlider.value;
				
				if ( ( this.entSliderOffset + 10 ) > this.allEntities.length )
				{
					this.entSliderOffset = this.allEntities.length - 10;
					
					if ( this.entSliderOffset < 0 )
					{
						this.entSliderOffset = 0;
					}
					sigSlider.value = this.entSliderOffset;
				}
				this.renderGraph();
			}
			
			/**
			 * Resets the ignore local filter flag and button
			 */
			protected function resetIgnoreLocalFilter():void
			{
				ignoreLocalFilter = false;
				localFilterSettings.toolTip = "Ignore Workspace Filtering - Show All Results";
				localFilterSettings.selected = false;
				localFilterSettings.dispatchEvent( new MouseEvent( MouseEvent.ROLL_OUT ) );
			}
			
			protected function sortOptions_changeHandler( event:IndexChangeEvent ):void
			{
				this.renderGraph();
			}
			
			/**
			 * function to add entities to the query
			 *
			 * @param event The MouseEvent received when the add to query button is pressed
			 */
			private function createExternalSearch( event:MouseEvent ):void
			{
				var urlComp:String = null;
				if (-1 != entityToSend.selectedIndex)
				{
					urlComp = encodeURIComponent( '"' + entityToSend.selectedItem.entity.disambiguated_name + '"' );
				}
				else 
				{
					urlComp = "";
					var temp:ArrayCollection = getSelectedIndexes();
					for each ( var chartIndex:int in temp )
					{
						var doc:Object = this.topEntitiesCombo.getItemAt(chartIndex);
						urlComp += encodeURIComponent( '"' +doc.entity.disambiguated_name + '"' ) + "%20";
					}
				}
				var externalUrl:String = ExternalInterface.call( 'getSearchUrl', urlComp );
				var url:URLRequest = new URLRequest( externalUrl );
				navigateToURL( url, '_blank' );
			}
			
			/**
			 * function to render the tool tip to display information about the entity being hovered over
			 *
			 * @param data The data for the given entity being hovered over
			 *
			 * @return The tool tip data for the entity
			 */
			private function dataTipFunction( data:HitData ):String
			{
				//create an instance of the Columnseries item
				var item:ColumnSeries3DItem = ColumnSeries3DItem( data.chartItem );
				
				var info:String = "<HTML><FONT COLOR=\"#FFFFFF\">";
				
				var filterOption:Boolean = false;
				
				var isPromoted:Boolean = !data.item.entity.hasOwnProperty("notPromoted");
				
				var sentiment:int = 0;
				
				info += "Entity: " + data.item.entity.disambiguated_name + "\n";
				if ( !isPromoted )
				{
					info += "(not present in promoted documents)\n";
				}
				
				if ( item.yValue == data.item.positiveSentiment )
				{
					info += "Positive Sentiment: " + data.item.positiveSentiment.toFixed( 3 ) + "\n";
					sentiment = 1;
					filterOption = true;
				}
				else if ( item.yValue == data.item.negativeSentiment )
				{
					info += "Negative Sentiment: " + data.item.negativeSentiment.toFixed( 3 ) + "\n";
					sentiment = -1;
					filterOption = true;
				}
				else if ( item.yValue == data.item.aggregateSentiment )
				{
					info += "Aggregate Sentiment: " + data.item.aggregateSentiment.toFixed( 3 ) + "\n";
					filterOption = true;
				}
				else if ( item.yValue == 0.0 )
				{
					info += "(separator)\n";
				}
				
				info += "Sentiment Count:" + data.item.sentimentCount + "\n";
				
				var rounded:Number = Math.round( data.item.queryCoverage );
				
				if ( rounded > 0 )
				{ // (this number is 0 a lot...)
					info += "Query coverage: " + Number( data.item.queryCoverage ).toFixed( 1 ) + "%\n";
				}
				else if ( data.item.queryCoverage >= 0.1 )
				{ // sigh there's probably a nicer way to do this....
					info += "Query coverage: 0." + Math.round( 100.0 * data.item.queryCoverage ) + "%\n";
				}
				else if ( data.item.queryCoverage >= 0.01 )
				{
					info += "Query coverage: 0.0" + Math.round( 1000.0 * data.item.queryCoverage ) + "%\n";
				}
				else if ( data.item.queryCoverage >= 0.001 )
				{
					info += "Query coverage: 0.00" + Math.round( 10000.0 * data.item.queryCoverage ) + "%\n";
				}
				else
				{
					info += "Query coverage: ~0%\n";
				}
				
				info += "Query Significance:" + Number( data.item.datasetSignificance ).toFixed( 1 ) + "%\n";
				info += "Average Frequency: " + Number( data.item.averageFreq ).toFixed( 1 ) + "\n";
				
				
				
				info += "Entity Type: " + data.item.entity.type + "\n";
				
				if ( !isPromoted )
				{
					info += "[Double Click: add entity to query]";					
				}
				else if ( filterOption )
				{
					if ( 1 == sentiment )
						info += "[Double Click: add documents with positive sentiment for this entity to filter]";
					else if ( -1 == sentiment )
						info += "[Double Click: add documents with negative sentiment for this entity to filter]";
					else
						info += "[Double Click: add documents containing highest positive and negative sentiment for this entity to filter]";						
				}
				else
				{
					info += "[Double Click: add documents with sentiment for this entity to filter]";
				}
				
				info += "</FONT></HTML?>";
				return info;
			}
			protected function chart_clickHandler( event:mx.charts.events.ChartEvent ):void
			{
				chart_itemSelectedHandler(null);
			}
			
			private function getSelectedIndexes():ArrayCollection
			{
				// Get an intial set of selected/unselected items...
				var items:Array = new Array(this.topEntitiesCombo.length);
				for (var i:int = 0; i < items.length; ++i) items[i] = 0;
				for each (var chartObj:ChartItem in chart.selectedChartItems)
				{
					items[chartObj.index]++;
				}
				var temp:ArrayCollection = new ArrayCollection();
				for (var j:int = 0; j < items.length; ++j) {
					if (items[j] > 0) { 
						temp.addItem(j);
					}
				}
				return temp;
			}
			
			protected function chart_itemSelectedHandler( event:mx.charts.events.ChartItemEvent ):void
			{	
				if (chart.selectedChartItems.length > 0)
				{
					var temp:ArrayCollection = getSelectedIndexes();
					
					dragImage.toolTip = "Drag this to another widget/the query bar to send selected entities";
					
					if (1 == temp.length)
					{
						entityToSend.selectedIndex = temp.getItemAt(0) as int;
					}
					else {
						entityToSend.prompt = "Multiple";
						entityToSend.selectedIndex = -1;						
					}
				}
				else 
				{
					dragImage.toolTip = "Drag this to another widget/the query bar to send all visible entities";
					entityToSend.prompt = "Entities";
					entityToSend.selectedIndex = -1;
				}
			}
			private function doneChangingFilter( event:TimerEvent ):void
			{
				if ( 0 == regexFilter.text.length )
				{
					_regexFilter = null;
					_regexActivateString = "";
				}
				else
				{
					_regexFilter = new RegExp( regexFilter.text, "i" );
					_regexActivateString = "<=";
				}
				if ( null != sigSlider ) // (else graph doesn't exist yet)
				{
					this.renderGraph();
				}
			}
			
			private function findMatchingDocs( instances:ArrayCollection ):void
			{
				this.filterEntities = new HashSet();
				var entityFilter:Boolean = false;
				
				if ( instances != null )
				{
					//loop through all instances
					for ( var i:int = 0; i < instances.length; i++ )
					{
						//cast to selected instance and find in original data
						var inst:SelectedInstance = instances[ i ] as SelectedInstance;
						
						for each ( var feed:Object in queryData )
						{
							if ( feed._id.toString() == inst.getfeedID() )
							{
								this.currData.addItem( feed );
								
								if ( null != inst.getEntities() && ( null != feed.entities ) )
								{
									// Can we confirm some entities have been filtered out?
									if ( feed.entities.length != inst.getEntities().length )
									{
										entityFilter = true;
									}
									
									// Unfortunately have to add entities regardless
									// (in case eg the last inst is filtered...)
									for each ( var ent:Object in inst.getEntities() )
									{
										this.filterEntities.add( ent ); // (this is the gaz index)
									}
								}
								break;
							}
						}
					}
				}
				
				if ( !entityFilter )
				{
					// (Can't do anything about expense just incurred, but at least
					//  won't incur them on the rendering side...)
					this.filterEntities = null;
				}
			}
			
			//(end regex hackery)
			
			/**
			 * function to format combo box labels
			 *
			 * @param _label The label to format
			 *
			 * @return The formatted Label
			 */
			private function formatLabel( _label:Object ):String
			{
				var label:String = "";
				label = _label.entity.disambiguated_name.toString() + " (" + _label.entity.type + ")";
				return label;
			}
			/**
			 * function to get the top frequency for the entities being displayed
			 *
			 * @param _entities The array of entities
			 *
			 * @return The top frequency of the top ten entities
			 */
			private function getFreq( _entities:Array ):Number
			{
				var freq:Number = 0;
				
				for ( var i:int = 0; ( i < 10 ) && ( ( i + this.entSliderOffset ) < _entities.length ); i++ )
				{
					var _ent:Object = new Object();
					_ent = _entities[ i + this.entSliderOffset ];
					
					if ( Number( _ent.frequency ) > freq )
					{
						freq = Number( _ent.frequency );
					}
					
					if ( Number( _ent.averageFreq ) > freq )
					{
						freq = Number( _ent.averageFreq );
					}
				}
				return freq;
			}
			
			private function graphFromAggregatedEntities():ArrayCollection
			{
				var entities:ArrayCollection = new ArrayCollection();
				
				for each ( var entity:Object in this.currData_entities )
				{
					if ( (null == entity.positiveSentiment) && (null == entity.negativeSentiment) )
						continue;
					
					var entContainer:Object = new Object;
					entContainer[ "entity" ] = entity;
					entContainer[ "queryCoverage" ] = entity.queryCoverage;
					entContainer[ "datasetSignificance" ] = entity.datasetSignificance;
					entContainer[ "averageFreq" ] = 100.0 * entity.averageFreq / entity.queryCoverage; // (QC is a % so /100 to turn into a multiplier...)
					entContainer[ "sentimentCount" ] = entity.sentimentCount;
					entContainer[ "positiveSentiment" ] = entity.positiveSentiment;
					entContainer[ "negativeSentiment" ] = entity.negativeSentiment;
					entContainer[ "aggregateSentiment" ] = entity.positiveSentiment + entity.negativeSentiment;
					
					// (average over documents in which the entity is present)
					entities.addItem( entContainer );
				}
				return entities;
			}
			
			/**
			 * function to render entities on the x axis
			 *
			 * @param axis The current axis
			 * @param data The data for the current axis
			 *
			 * @return The information for the current axis
			 */
			private function hAxisDataFunction( axis:Object, data:Object ):Object
			{
				if ( data != null )
				{
					return data.entity.disambiguated_name.toString() + " (" + data.entity.type.toString() + ")";
				}
				else
					return "";
			}
			
			private function onChangeEntityFilter( event:Event ):void
			{
				// Start a timer for 300ms time
				this._filterModifyTimer.stop();
				this._filterModifyTimer.start();
			}
			// This function handles clicking the "ignore local filter" button:
			// - If no filter is applied, sets a flag
			// - If a filter is applied and "ignore filter" is currently "true":
			//    - Sets flag and re-calls receivedSelectedResults with the previously saved filtered results
			// - If a filter is applied and "ignore filter" is currently "false"
			//    - Sets flag and restores previously saved unfiltered results
			
			private function onClickIgnoreLocalFilter():void
			{
				internalFilterUpdate = true;
				this.ignoreLocalFilter = !this.ignoreLocalFilter;
				
				if ( !this.ignoreLocalFilter )
				{
					if ( hasFilter )
						this.onReceiveNewFilter();
					else
						this.onReceiveNewQuery();
					ignoreLocalFilter = false;
					localFilterSettings.toolTip = "Ignore Workspace Filtering - Show All Results";
					localFilterSettings.selected = false;
					localFilterSettings.dispatchEvent( new MouseEvent( MouseEvent.ROLL_OUT ) );
				}
				else
				{
					this.onReceiveNewQuery();
					ignoreLocalFilter = true;
					localFilterSettings.toolTip = "Apply Workspace Filtering - Show Filtered Results";
					localFilterSettings.selected = true;
					localFilterSettings.dispatchEvent( new MouseEvent( MouseEvent.ROLL_OUT ) );
				}
				internalFilterUpdate = false;
			}
			
			/**
			 * Method fired when module is done loading.  Sends
			 * message to parent letting it know that module is
			 * ready to receive data.
			 */
			private function onWidgetCreationComplete( event:Event ):void
			{
				_filterModifyTimer.addEventListener( TimerEvent.TIMER_COMPLETE, doneChangingFilter );
			}
			
			private function populateGraph():void
			{
				if ( ( this.currData != null && this.currData.length > 0 ) || ( this.currData_entities != null && this.currData_entities.length > 0 ) )
				{
					//instantiate a hashset to hold all the entities so that there are no duplicates
					var entities:HashSet = new HashSet();
					
					// Get a single set of entities from all the feeds
					
					if ( this.currData_entities != null && this.currData_entities.length > 0 )
					{ // Use entities if we can...
						this.allEntities = graphFromAggregatedEntities().toArray();
					}
					else
					{ // Use documents if we have to
						this.allEntities = removeDups( this.currData ).toArray();
					}
				}
			}
			private function renderGraph():void
			{
				// (remove selection)
				chart_itemSelectedHandler(null);
				
				if ( this.currData_entities != null && this.currData_entities.length > 0 )
				{ // Use entities if we can...					
					
					if ( sortOptions.selectedIndex == SORT_BY_QUERY_COVERAGE )
					{
						this.allEntities.sortOn( "queryCoverage", Array.DESCENDING | Array.NUMERIC );
					}
					else if ( sortOptions.selectedIndex == SORT_BY_SIGNIFICANCE )
					{
						this.allEntities.sortOn( "datasetSignificance", Array.DESCENDING | Array.NUMERIC );
					}
					else if ( sortOptions.selectedIndex == SORT_BY_AVERAGE_FREQUENCY )
					{
						this.allEntities.sortOn( "averageFreq", Array.DESCENDING | Array.NUMERIC );
					}
					else if ( sortOptions.selectedIndex == SORT_BY_POSITIVE_SENTIMENT )
					{
						this.allEntities.sortOn( "positiveSentiment", Array.DESCENDING | Array.NUMERIC );
					}
					else if ( sortOptions.selectedIndex == SORT_BY_NEGATIVE_SENTIMENT )
					{
						this.allEntities.sortOn( "negativeSentiment", Array.NUMERIC );
					}
					else if ( sortOptions.selectedIndex == SORT_BY_POSITIVE_AGGREGATE_SENTIMENT )
					{
						this.allEntities.sortOn( "aggregateSentiment", Array.DESCENDING | Array.NUMERIC );
					}
					else if ( sortOptions.selectedIndex == SORT_BY_NEGATIVE_AGGREGATE_SENTIMENT )
					{
						this.allEntities.sortOn( "aggregateSentiment", Array.NUMERIC );
					}
					
					// Display the following fields:
					// Query coverage (%)
					// Query Significance (%)
					// (max) Doc significance (%)
					// Average frequency
					// (max) Doc frequency
					// (also have a separator					
					
					//store the top 10 entities into a seperate array
					var topEntities:ArrayCollection = new ArrayCollection();
					entityToSend.selectedIndex = -1;
					topEntitiesCombo = new ArrayCollection();
					
					var maxFreq:int = getFreq( allEntities );
					
					// (Regex code - step over the specified number of *unfiltered* entities)
					var j:int = 0;
					var i:int = this.entSliderOffset;
					
					if ( null != _regexFilter )
					{
						for ( i = 0; ( i < this.allEntities.length ) && ( j < this.entSliderOffset ); ++i )
						{
							var ent2:Object = this.allEntities[ i ];
							
							if ( _regexFilter.test( ent2.entity.disambiguated_name + " ( " + ent2.entity.type + " ) " + ent2.entity.dimension ) )
							{
								j++;
							}
						}
						j = 0;
					}
					entitiesOnDisplay.clear();
					for ( ; ( j < 10 ) && ( i < this.allEntities.length ); i++, j++ )
					{
						var ent:Object = this.allEntities[ i ];
						
						if ( null != _regexFilter )
						{
							if ( !_regexFilter.test( ent.entity.disambiguated_name + " ( " + ent.entity.type + " ) " + ent.entity.dimension ) )
							{
								j--;
								continue;
							}
						}
						
						ent[ "augFrequency" ] = Math.ceil( ( this.maxSig / maxFreq ) * Number( ent.frequency ) );
						ent[ "augAvgFrequency" ] = Math.ceil( ( this.maxSig / maxFreq ) * Number( ent.averageFreq ) );
						ent[ "zero" ] = 0;
						
						// Since the tooltips dubiously use y-value to work out which field is which, need to ensure
						// that the similar numbers don't get confused
						if ( ent.augFrequency == ent.augAvgFrequency )
						{
							ent.augAvgFrequency += 0.0001;
								// (need to leave freq alone since it's used for finding the right feed)
						}
						
						if ( ent.significance == ent.datasetSignificance )
						{
							ent.datasetSignificance += 0.0001;
								// (need to leave sig alone since it's used for finding the right feed)
						}
						
						if ( ent.significance == ent.queryCoverage )
						{
							ent.queryCoverage += 0.0001;
								// (need to leave sig alone since it's used for finding the right feed)
						}
						
						if ( ent.positiveSentiment == ent.aggregateSentiment || ent.positiveSentiment == 0 )
						{
							ent.positiveSentiment += 0.0001;
						}
						
						if ( ent.negativeSentiment == ent.aggregateSentiment || ent.negativeSentiment == 0 )
						{
							ent.negativeSentiment -= 0.0001;
						}
						
						if ( ent.aggregateSentiment == 0 )
						{
							ent.aggregateSentiment += 0.0001;
						}
						
						topEntities.addItem( ent );
						topEntitiesCombo.addItem( ent );
						
						entitiesOnDisplay.put(ent.entity.disambiguated_name.toString() + " (" + ent.entity.type + ")", ent);
					}
					entityToSend.dataProvider = this.topEntitiesCombo;
					entityToSend.validateNow();
					
					setSeriesEffect( interpolateIn );
					chart.dataProvider = topEntities;
					
					_hasData = true;
				}
				else
				{
					this.currentState = "nodata";
				}
				this.enabled = true;
			}
			
			/**
			 * function to remove duplicate entities
			 *
			 * @param entities The list of entities to remove duplicates from
			 *
			 * @return The hashset of non duplicate entities
			 */
			private function removeDups( feeds:ArrayCollection ):ArrayCollection
			{
				this.maxSig = 0;
				
				var entities:HashMap = new HashMap();
				
				//loop through the knowledge arrayCollection to get all the feed objects
				for each ( var feed:Object in feeds )
				{
					//loop through the feed objects to get all the entities and add them to the hashset
					for each ( var entity:Object in feed.entities )
					{
						if ( entity.significance > this.maxSig )
						{
							this.maxSig = entity.significance;
						}
						
						if ( entity.datasetSignificance > this.maxSig )
						{
							this.maxSig = entity.datasetSignificance;
						}
						
						if ( entity.queryCoverage > this.maxSig )
						{
							this.maxSig = entity.queryCoverage;
						}
						
						var savedEnt:Object = entities.get( entity.index );
						
						if ( null != savedEnt )
						{
							// Get the maximum values:
							if ( entity.positiveSentiment > savedEnt.positiveSentiment )
							{
								savedEnt.positiveSentiment = entity.positiveSentiment;
							}
							
							if ( entity.negativeSentiment < savedEnt.negativeSentiment )
							{
								savedEnt.negativeSentiment = entity.negativeSentiment;
							}
							// Replace: can't imagine we need to do this, but empirically it seemed to be the case							
							entities.put( entity.index, savedEnt );
						}
						else
						{
							if ( null != this.filterEntities )
							{
								// (Entity filter has been applied)
								if ( !this.filterEntities.contains( entity.index ) )
								{
									continue; // Don't have this one
								}
							}
							var entContainer:Object = new Object;
							entContainer[ "entity" ] = entity;
							entContainer[ "queryCoverage" ] = entity.queryCoverage;
							entContainer[ "datasetSignificance" ] = entity.datasetSignificance;
							entContainer[ "averageFreq" ] = 100.0 * entity.averageFreq / entity.queryCoverage; // (QC is a % so /100 to turn into a multiplier...)
							entContainer[ "positiveSentiment" ] = entity.positiveSentiment;
							entContainer[ "negativeSentiment" ] = entity.negativeSentiment;
							entContainer[ "aggregateSentiment" ] = entity.positiveSentiment + entity.negativeSentiment;
							entContainer[ "sentimentCount" ] = entity.sentimentCount;
							// (average over documents in which the entity is present)
							entities.put( entity.index, entContainer );
						}
					} // end loop over ents in feeds
				} // end loop over feeds
				
				return new ArrayCollection( entities.getValues() );
			}
			
			/**
			 * function to add entities to the query
			 *
			 * @param event The MouseEvent received when the add to query button is pressed
			 */
			private function send2Query( event:MouseEvent ):void
			{
				if ( -1 != this.entityToSend.selectedIndex )
				{
					var sentimentDir:int = getSentimentDir(this.entityToSend.selectedIndex);
					if ( sentimentDir > 0 )
						send2Query_internal( entityToSend.selectedItem.entity.index, true, true, 0.0000001, false, 0.0 );
					else if ( sentimentDir < 0 )
						send2Query_internal( entityToSend.selectedItem.entity.index, true, false, 0.0, true, -0.0000001 );
					else
						send2Query_internal( entityToSend.selectedItem.entity.index, true );
				}
				else // multiple or none 
				{
					var temp:ArrayCollection = getSelectedIndexes();
					if (temp.length > 0)
					{
						send2Query_internal_multiple(temp, true);
					}					
				}
			}
			private function getSentimentDir(index:int):int
			{
				if ( (chart.series[0] as ColumnSeries3D).selectedIndex == index )
					return 1;
				else if ( (chart.series[2] as ColumnSeries3D).selectedIndex == index )
					return -1;
				else
					return 0;				
			}
			
			private function send2Query_internal( index:String, specSent:Boolean = false, specMinSent:Boolean = false, minSent:Number = 0.0, specMaxSent:Boolean = false, maxSent:Number = 0.0 ):void
			{
				var query:Object = _context.getCurrentQuery();
				var queryTerms:ArrayCollection = new ArrayCollection( query[ "qt" ] );
				var newTerm:Object = new Object();
				newTerm[ "entity" ] = index;
				if (specSent)
				{
					var sent:Object = new Object();
					if (specMinSent)
					{
						sent[ "min" ] = minSent;
					}
					if (specMaxSent)
					{
						sent[ "max" ] = maxSent;
					}
					newTerm[ "sentiment" ] = sent;
				}
				queryTerms.addItem( newTerm );
				_context.setCurrentQuery( query, "qt" );
			}
			private function send2Query_internal_multiple( indexArray:ArrayCollection, specSent:Boolean = false ):void
			{
				var query:Object = _context.getCurrentQuery();
				var queryTerms:ArrayCollection = new ArrayCollection( query[ "qt" ] );
				for each ( var index:int in indexArray ) {
					var ent:Object = this.topEntitiesCombo.getItemAt(index);
					var newTerm:Object = new Object();
					newTerm[ "entity" ] = ent.entity.index;
					if ( specSent )
					{
						var sent:Object = new Object();
						var sentimentDir:int = getSentimentDir(index);
						if ( sentimentDir > 0 )
						{
							sent[ "min" ] = 0.0000001;
						}
						else if ( sentimentDir < 0 ) 
						{
							sent[ "max" ] = -0.0000001;							
						}
						newTerm[ "sentiment" ] = sent;
					}
					queryTerms.addItem( newTerm );
				}
				_context.setCurrentQuery( query, "qt" );
			}
			
			/**
			 * function to load data for each series
			 *
			 * @param series The current series
			 * @param data The data for the current series
			 * @param field The field for the series
			 *
			 * @return The series information
			 */
			private function seriesDataFunction( series:Series, data:Object, field:String = null ):Object
			{
				return data.frequency.toString();
			}
			
			/**
			 * function to add an effect to the series when data is changed
			 *
			 * @param effect The effect to add to the series
			 */
			private function setSeriesEffect( effect:SeriesEffect ):void
			{
				aggregateSentiment.setStyle( 'showDataEffect', effect );
				negativeSentiment.setStyle( 'showDataEffect', effect );
				positiveSentiment.setStyle( 'showDataEffect', effect );
			}
			
			/**
			 * function to render the values on the y axis
			 *
			 * @param o The object at the current location
			 * @param v The value at the current location
			 *
			 * @return The current value at that location
			 */
			private function vAxisLabelFunction( o:Object, v:Object ):String
			{
				return v.toString();
			}
		]]>
	</fx:Script>
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
		<mx:SeriesInterpolate id="interpolateIn"
			duration="1000" />
		<actionscript:CartesianChart3DControl chart="{ chart }" />
		<s:SolidColorStroke id="seriesStroke"
			color="0x222222"
			alpha="0.5" />
	</fx:Declarations>

	<!-- Header -->
	<components:headerContent>

		<s:HGroup gap="-3">

			<!-- Drag icon -->
			<components:WidgetHeaderDragImage
				id="dragImage"  
				mouseDown="widgetheaderdragimage1_mouseDownHandler(event)" 
				toolTip="Drag this to another widget/the query bar to send visible entities" />
			
			<!-- Ignore Filter Toggle Button -->
			<components:WidgetIgnoreFilterToggleButton id="localFilterSettings"
				toolTip="Ignore Workspace Filtering - Show All Results"
				click="setTimeout( onClickIgnoreLocalFilter, 100 )" />

			<!-- Entities Drop Down List -->
			<components:WidgetDropDownList id="entityToSend"
				width="140"
				selectedIndex="-1"
				labelFunction="formatLabel"
				dataProvider="{ topEntitiesCombo }"
				listWidth="400"
				prompt="Entities" />

			<!-- Add to Query Button -->
			<components:WidgetPlusButton id="addToQueryButton"
				toolTip="Add to Query (including +/-/* sentiment)"
				click="send2Query(event)" />

			<!-- External search button -->
			<components:WidgetHeaderButton id="doExternalSearchButton"
				height="100%"
				label="{ ExternalInterface.call( 'getSearchProvider' ) }"
				toolTip="Perform external search on the selected entity"
				includeInLayout="{ !( ExternalInterface.call( 'getSearchProvider' ) == null || ExternalInterface.call( 'getSearchProvider' ) == '' ) }"
				click="createExternalSearch(event)"
				visible="{ !( ExternalInterface.call( 'getSearchProvider' ) == null || ExternalInterface.call( 'getSearchProvider' ) == '' ) }" />

			<!-- Sort Options Drop Down List -->
			<components:WidgetDropDownList id="sortOptions"
				width="168"
				selectedIndex="{ SORT_BY_SIGNIFICANCE }"
				change="setTimeout( sortOptions_changeHandler, 100, event )"
				listWidth="266">
				<components:dataProvider>
					<s:ArrayList source="[Rank by Significance,Rank by Coverage,Rank by Frequency,Rank by Positive Sentiment,Rank by Negative Sentiment,Rank by Positive Aggregate Sentiment,Rank by Negative Aggregate Sentiment]" />
				</components:dataProvider>
			</components:WidgetDropDownList>

			<!-- regex filtering box -->
			<s:HGroup 
				height="100%"
				paddingBottom="2"
				paddingLeft="5"
				paddingRight="7"
				paddingTop="2"
				verticalAlign="middle">
				<components:WidgetTextInput id="regexFilter"
					width="100"
					toolTip="Enter a regex string to filter entities on name, type or dimension"
					change="onChangeEntityFilter(event)"
					prompt="Show only:" />
			</s:HGroup>

		</s:HGroup>

	</components:headerContent>

	<s:VGroup 
		width="100%"
		height="100%"
		horizontalAlign="center"
		verticalAlign="middle"
		includeIn="nodata">
		<s:Label 
			text="No data, try running a query"
			includeIn="nodata" />
	</s:VGroup>

	<s:VGroup 
		width="100%"
		height="100%"
		horizontalAlign="center"
		gap="0"
		includeIn="dataview">

		<!-- Graph -->

		<mx:ViewStack id="views"
			width="100%"
			height="100%"
			creationPolicy="all"
			includeIn="dataview">
			<s:NavigatorContent 
				width="100%"
				height="100%">
				<s:Rect 
					width="100%"
					height="100%">
					<s:fill>
						<s:LinearGradient rotation="90">
							<s:entries>
								<s:GradientEntry color="0x000000" />
								<s:GradientEntry color="0x323232" />
							</s:entries>
						</s:LinearGradient>
					</s:fill>
				</s:Rect>
				<s:HGroup 
					width="100%"
					height="100%">
					<ilog:ColumnChart3D id="chart"
						width="80%"
						height="100%"
						x="0"
						color="0xFFFFFF"
						top="50"
						selectionMode="multiple"
						doubleClickEnabled="true"
						itemClick="chart_itemSelectedHandler(event)"
						doubleClick="chart_doubleClickHandler(event)"
						chartClick="chart_clickHandler(event)"
						itemDoubleClick="chart_itemClickHandler(event)"						
						mouseOver="chart_mouseOver(event)"						
						columnWidthRatio="0.9"
						dataTipCalloutStroke="{ seriesStroke }"
						dataTipFunction="dataTipFunction"
						depth="5"
						elevationAngle="40"
						rotationAngle="50"
						showDataTips="true"
						type="clustered">
						<ilog:wallsFill>
							<s:LinearGradient rotation="30">
								<s:GradientEntry color="0x444444" />
								<s:GradientEntry 
									color="0x000000"
									alpha="0.0" />
							</s:LinearGradient>
						</ilog:wallsFill>

						<ilog:wallsStroke>
							<s:SolidColorStroke 
								color="0xFFFFFF"
								alpha="0.4"
								weight="1" />
						</ilog:wallsStroke>
						<ilog:verticalAxisRenderer>
							<ilog:AxisRenderer3D 
								labelFunction="vAxisLabelFunction"
								axisWidth="0"
								minorTickPlacement="none" />
						</ilog:verticalAxisRenderer>
						<ilog:horizontalAxisRenderer>
							<ilog:AxisRenderer3D 
								axisWidth="0"
								minorTickLength="0"
								minorTickPlacement="inside">
								<ilog:tickStroke>
									<s:SolidColorStroke color="0xFF0000" />
								</ilog:tickStroke>
								<ilog:fill>
									<mx:SolidColor color="0x333333" />
								</ilog:fill>
							</ilog:AxisRenderer3D>
						</ilog:horizontalAxisRenderer>
						<ilog:horizontalAxis>
							<mx:CategoryAxis id="entityAxis"
								dataFunction="hAxisDataFunction" />
						</ilog:horizontalAxis>
						<ilog:series>
							<ilog:ColumnSeries3D id="positiveSentiment"
								displayName="Positive Sentiment"
								fill="{ new SolidColor( 0x00FF00 ) }"
								stroke="{ seriesStroke }"
								yField="positiveSentiment" />
							<ilog:ColumnSeries3D id="aggregateSentiment"
								displayName="Aggregate Sentiment"
								fill="{ new SolidColor( 0x00BFFF ) }"
								stroke="{ seriesStroke }"
								yField="aggregateSentiment" />
							<ilog:ColumnSeries3D id="negativeSentiment"
								displayName="Negative Sentiment"
								fill="{ new SolidColor( 0xFF0000 ) }"
								stroke="{ seriesStroke }"
								yField="negativeSentiment" />

							<ilog:ColumnSeries3D id="separator"
								fill="{ null }"
								stroke="{ seriesStroke }"
								yField="zero" />
						</ilog:series>
					</ilog:ColumnChart3D>
					<!--<mx:Spacer height="5"/>-->
					<s:VGroup 
						width="20%"
						height="15%"
						horizontalAlign="left"
						paddingLeft="10"
						paddingRight="10"
						paddingTop="20"
						gap="0">
						<s:Label 
							text="Legend"
							color="0xFFFFFF"
							fontWeight="bold" />
						<mx:Legend 
							dataProvider="{ chart }"
							color="0xFFFFFF"
							verticalAlign="bottom" />
					</s:VGroup>
				</s:HGroup>

			</s:NavigatorContent>
		</mx:ViewStack>

		<!-- Footer -->

		<components:WidgetFooterGroup 
			width="100%"
			contentBackgroundColor="0x2E2E2E">

			<s:VGroup id="sigContainer"
				width="100%"
				horizontalAlign="center"
				paddingBottom="9"
				paddingLeft="10"
				paddingRight="10"
				paddingTop="9"
				verticalAlign="middle"
				gap="0">
				<s:Label id="percentile"
					width="100%"
					text="Step through { _regexActivateString }{ allEntities.length } entities (\@{ sigSlider.value }):"
					color="#FFFFFF"
					fontWeight="bold"
					textAlign="center" />
				<s:HGroup 
					width="100%"
					horizontalAlign="center"
					verticalAlign="middle">
					<s:Button id="minusSlider"
						toolTip="Step Back 10"
						width="20"
						height="20"
						click="sigSlider.value -= 10; entitySliderUpdate(event);"
						skinClass="skins.SliderMinusButtonSkin" />
					<s:HSlider id="sigSlider"
						width="100%"
						stepSize="1"
						minimum="0"
						maximum="{ allEntities.length }"
						liveDragging="false"
						change="entitySliderUpdate(event)" />
					<s:Button id="plusSlider"
						toolTip="Step Forward 10"
						width="20"
						height="20"
						click="sigSlider.value += 10; entitySliderUpdate(event);"
						skinClass="skins.SliderPlusButtonSkin" />
				</s:HGroup>
			</s:VGroup>
		</components:WidgetFooterGroup>

	</s:VGroup>

</components:WidgetModule>
