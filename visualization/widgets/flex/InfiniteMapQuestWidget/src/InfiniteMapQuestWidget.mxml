<?xml version="1.0" encoding="utf-8"?>
<components:WidgetModule xmlns:fx="http://ns.adobe.com/mxml/2009"
	xmlns:components="com.ikanow.infinit.e.widget.library.components.*"
	xmlns:components1="com.ikanow.infinit.e.components.*"
	xmlns:ilog="http://www.ilog.com/2007/ilog/flex"
	xmlns:tilemap="com.mapquest.tilemap.*"
	xmlns:s="library://ns.adobe.com/flex/spark"
	xmlns:mx="library://ns.adobe.com/flex/mx"
	implements="com.ikanow.infinit.e.widget.library.widget.IWidget"
	creationComplete="{ try { onWidgetCreationComplete(); } catch (e:Error) {  } dispatchEvent(new Event('Done Loading')); }">
	<fx:Style source="/com/ikanow/infinit/e/assets/styles/infiniteStyles.css" />
	<fx:Style>
		@namespace s "library://ns.adobe.com/flex/spark";
		@namespace mx "library://ns.adobe.com/flex/mx";
		/* If you need to override a style in our stylesheet, or add another
		style that we did not support you can do so here, an example has been commented out
		Please see documentation about over-riding MX component styles to display fonts*/
		/*
		mx|Text
		{
		font-family: infiniteNonCFFFont;
		}
		*/
	</fx:Style>
	<fx:Script>
		<![CDATA[
			import com.ikanow.infinit.e.actionscript.InfiniteClusterIcons;
			import com.ikanow.infinit.e.actionscript.InfiniteMapPresentationLayer;
			import com.ikanow.infinit.e.components.InfininiteRollover;
			import com.ikanow.infinit.e.components.InfiniteRolloverWindow;
			import com.ikanow.infinit.e.components.RolloverWindow;
			import com.ikanow.infinit.e.widget.library.data.WidgetSaveObject;
			import com.ikanow.infinit.e.widget.library.widget.IWidget;
			import com.ikanow.infinit.e.widget.library.widget.IWidgetContext;
			import com.mapquest.DistanceUnits;
			import com.mapquest.LatLngCollection;
			import com.mapquest.tilemap.RectLL;
			import com.mapquest.tilemap.RemoteCollection;
			import com.mapquest.tilemap.ShapeCollection;
			import com.mapquest.tilemap.TileMap;
			import com.mapquest.tilemap.TileMapEvent;
			import com.mapquest.tilemap.controls.inputdevice.MouseWheelZoomControl;
			import com.mapquest.tilemap.controls.shadymeadow.SMLargeZoomControl;
			import com.mapquest.tilemap.deserializers.DeserializeKML;
			import com.mapquest.tilemap.overlays.CircleOverlay;
			import com.mapquest.tilemap.pois.ImageMapIcon;
			import com.mapquest.tilemap.pois.MapIcon;
			import com.mapquest.tilemap.pois.Poi;
			import mx.collections.ArrayCollection;
			import mx.collections.XMLListCollection;
			import mx.controls.Alert;
			import mx.controls.LinkButton;
			import mx.controls.Menu;
			import mx.events.FlexMouseEvent;
			import mx.events.ItemClickEvent;
			import mx.events.MenuEvent;
			import mx.events.ResizeEvent;
			import mx.graphics.SolidColorStroke;
			import mx.managers.PopUpManager;
			import spark.components.BorderContainer;
			import spark.components.Label;
			import spark.components.VGroup;
			import spark.effects.RemoveAction;
			import spark.events.IndexChangeEvent;
			import spark.primitives.Line;
			import org.alivepdf.fonts.FontFamily;
			import org.alivepdf.fonts.Style;
			import org.alivepdf.images.ImageFormat;
			import org.alivepdf.images.ResizeMode;
			import org.alivepdf.layout.Orientation;
			import org.alivepdf.layout.Size;
			import org.alivepdf.layout.Unit;
			import org.alivepdf.pages.Page;
			import org.alivepdf.pdf.PDF;
			import system.data.Map;
			import system.data.sets.HashSet;
			
			private static const MAP_OVERLAY:int = 0;
			
			private static const SATTELITE_OVERLAY:int = 1;
			
			private static const TERRAIN_OVERLAY:int = 2;
			
			private static const HYBRID_OVERLAY:int = 3;
			
			public var SHOW_HEAT_MAP:Boolean = true;
			
			public var SHOW_GEO_DOCUMENTS:Boolean = true;
			
			public var SHOW_GEO_ENTITIES:Boolean = true;
			
			public var SHOW_GEO_EVENTS:Boolean = true;
			
			public var SHOW_KML_LAYERS:Boolean = true;
			
			// Determines if filtering results are immediately applied:
			public var ignoreLocalFilter:Boolean = false;
			
			public var internalFilterUpdate:Boolean = false;
			
			public var hasFilter:Boolean = false;
			
			// 3.1.2] Constants
			
			private const API_KEY:String = flash.external.ExternalInterface.call( "getMapLicenseKey" );
			
			private const ENDPOINT_URL:String = flash.external.ExternalInterface.call( "getEndPointUrl" );
			
			// 3.1.3] Bindable parameters / other GUI-specific objects
			
			//(some horrible visualization hackery)			
			private var _mapResizeTimer:Timer = null;
			
			// Heatmap backing data:
			[Bindable]
			private var _heatMapData:XMLListCollection = new XMLListCollection();
			
			// Demo region select state:
			private var _regionSelectMarker:Poi = null;
			
			private var _regionStartLatLng:LatLng = null;
			
			private var _regionEndLatLng:LatLng = null;
			
			private var _regionRadiusSelect:Boolean = false;
			
			private var _regionRadiusDrag:Boolean = false;
			
			private var _regionSelectRadius:CircleOverlay = null;
			
			private var _regionPopUp:BorderContainer = null;
			
			private var _regionOptionPopUp:BorderContainer = null;
			
			private var _regionTimer:Timer;
			
			private var _mouseStart:Point = null;
			
			private var _mouseEnd:Point = null;
			
			//hide markers
			private var _mapMarkerBounds:RectLL = null;
			
			private var _needRecenter:Boolean = false;
			
			//loading last setup
			private var widgetOptions:Object = null;
			
			// 3.1.4] Presentation Layer object
			
			private var _presentationLayer:InfiniteMapPresentationLayer =
				new InfiniteMapPresentationLayer( this as InfiniteMapQuestWidget, this as InfiniteMapQuestWidget );
			
			// setHeatMapAvailable_fromPresentation - Allows the presentation layer to tell the GUI if a heat map can be displayed
			//
			// @param available: whether heat map data is available
			
			// (Some unpleasant state logic to handle the (framework failure?) case where this is set before 
			//  the map is ready...)
			private var _nSavedHeatMapState:int = -1;
			
			private var _kmlData:String = null;
			
			//private var _kmlLoader:GoogleMapKMLLoader = null;
			
			private var layersOn:Boolean = false;
			
			private var _layerUrl:Object = null;
			
			private var _ontologyMenu:Menu = null;
			
			private var rolloverWindow:InfininiteRollover;
			
			private var remoteCollection:ArrayCollection = new ArrayCollection();
			
			private var kmlCollection:ArrayCollection = new ArrayCollection();
			
			[Bindable]
			private var kmlLayerNames:ArrayCollection = new ArrayCollection();
			
			public function isHeatMapEnabled_fromPresentation():Boolean
			{
				if ( _nSavedHeatMapState >= 0 )
				{
					SHOW_HEAT_MAP = ( 1 == _nSavedHeatMapState );
					var showOption:Object = _presentationLayer.getShowOptions().getItemAt( 0 ) as Object;
					showOption.toggled = SHOW_HEAT_MAP;
					_heatMapMiddelay.visible = SHOW_HEAT_MAP && ( 1 == _nSavedHeatMapState );
					_nSavedHeatMapState = -1;
				}
				
				return ( _heatMapMiddelay.visible && SHOW_HEAT_MAP );
			}
			
			// Event to load the Kml into the parser
			public function loadKml( event:Event ):void
			{
			/*_kmlLoader = new GoogleMapKMLLoader( _map, "Google Map Layer" );
			_kmlLoader.showPolygonEdges = true;
			_kmlLoader.opacity = 0.5;  //50% opacity no need for this
			_kmlData = event.target.data;
			
			// Need to re-render markers first (clears other overlays) then this KML:
			_presentationLayer.onMapSizeChanged_fromGUI( _map.boundsLL as RectLL, _map.zoom, _map );*/
			}
			
			// Load Url of KML file and fire event upon complete to kml parser
			public function loadUrl( url:String ):void
			{
				try
				{
					var loader:URLLoader = new URLLoader();
					loader.addEventListener( Event.COMPLETE, loadKml );
					loader.load( new URLRequest( url ) );
				}
				catch ( e:Error )
				{
					Alert.show( "Error loading layer, check the hostname and URL: " + url );
				}
			}
			
			/**
			 * Allow users to export the widget contents in the specified format
			 * @format filename: the filename+path to which the data will be written (in case it needs to be embedded)
			 * @param format: the format from the "supportedFormats" call
			 *
			 * @returns a ByteArray containing the data to output
			 */
			public function onGenerateExportData( filename:String, format:String ):ByteArray
			{
				var ba:ByteArray = new ByteArray();
				
				switch ( format.toLowerCase() )
				{
					case "kml":
						ba = createKML();
						break;
					default:
						break;
				}
				
				
				return ba;
			}
			/**
			 * function to build a pdf version of the widget
			 *
			 * @return pdf version of the widget
			 */
			public function onGeneratePDF( printPDF:PDF, title:String ):PDF
			{
				return null;
			}
			
			/**
			 * If a save string has been saved from 'getSaveString' then
			 * when the app gets reloaded the last save string
			 * will be passed to this function.
			 *
			 * @param saveString the last save string or null if there was none
			 */
			public function onLoadWidgetOptions( widgetOptions:WidgetSaveObject ):void
			{
				resetKMLCollections();
				
				if ( widgetOptions != null )
				{
					//this holds a users last map 
					if ( widgetOptions.userSave != null )
					{
						this.widgetOptions = widgetOptions.userSave;
					}
					
					//this holds kml supplied by a community
					if ( widgetOptions.communitySave != null )
					{
						var keys:Array = widgetOptions.communitySave.getKeys();
						var vals:Array = widgetOptions.communitySave.getValues();
						
						//loop over every kml url and load them all up
						for ( var i:int = 0; i < keys.length; i++ )
						{
							//The keys are the commid, the val is a map of name -> kml urls
							var kmlMap:Object = vals[ i ];
							var kmlKeys:Array = kmlMap.keys;
							var kmlVals:Array = kmlMap.values;
							
							for ( var j:int = 0; j < kmlVals.length; j++ )
							{
								var url:String = kmlVals[ j ];
								url = url.replace( "\$infinite/", ENDPOINT_URL );
								var remoteColl:RemoteCollection = new RemoteCollection( url, DeserializeKML );
								remoteColl.name = getKmlName( keys[ i ], kmlKeys[ j ] );
								remoteColl.addEventListener( RemoteCollection.REMOTE_COLLECTION_LOADED, kmlLoaded );
								remoteColl.addEventListener( RemoteCollection.REMOTE_COLLECTION_FAILED, kmlFailed );
								kmlCollection.addItem( remoteColl );
							}
						}
					}
				}
			}
			
			/**
			 * function to rescale the module when the parent container is being resized
			 *
			 * @param newHeight The new height the component needs to be set to
			 * @param newWidth The new width the component needs to be set to
			 */
			public function onParentResize( newHeight:Number, newWidth:Number ):void
			{
				this.height = newHeight;
				this.width = newWidth;
				
				if ( null != _mapResizeTimer && !SHOW_HEAT_MAP )
				{ // ie need map to be ready
					// Turn heat map off - it's too slow to redraw
					_heatMapMiddelay.visible = false;
					
					// Start a timer for 100ms time
					this._mapResizeTimer.stop();
					this._mapResizeTimer.start();
				}
			}
			
			/**
			 * This function gets called when the workspace is being saved.
			 * return null if no save string is needed.
			 *
			 * @return a string this widget can use to reload state
			 */
			public function onSaveWidgetOptions():Object
			{
				var tempWidgetOptions:Object = new Object();
				tempWidgetOptions[ "centerLat" ] = _map.center.lat;
				tempWidgetOptions[ "centerLng" ] = _map.center.lng;
				tempWidgetOptions[ "zoomLevel" ] = _map.zoom;
				tempWidgetOptions[ "openKMLLayers" ] = new Array();
				
				for each ( var layer:Object in kmlLayerNames )
				{
					if ( layer.toggled )
						tempWidgetOptions[ "openKMLLayers" ].push( layer.label );
				}
				return tempWidgetOptions;
			}
			
			public function recenterAndZoomMap_fromPresentation( minLat:Number, minLng:Number, maxLat:Number, maxLng:Number, override:Boolean = false ):void
			{
				if ( null == _mapResizeTimer )
				{ // Always auto-zoom if just opened, unless loading last setup
					_mapMarkerBounds = new RectLL( new LatLng( maxLat, minLng ), new LatLng( minLat, maxLng ) );
					_needRecenter = true;
				}
				else
				{
					if ( override || !zoomToggleButton.selected )
					{
						_mapMarkerBounds = new RectLL( new LatLng( maxLat, minLng ), new LatLng( minLat, maxLng ) );
						_needRecenter = true;
					}
				}
			}
			
			// renderHeatMapOverlay_fromPresentation - displays the heatmap if available
			//
			// @param geoArray: an XML list of x,y (pixels) 
			
			public function renderHeatMapOverlay_fromPresentation( geoArray:XMLList ):void
			{
				if ( null == geoArray )
				{
					_heatMapData.removeAll();
					_heatMapMiddelay.visible = false;
				}
				else
				{
					_heatMapData.source = geoArray;
						//(Can't have got here unless heat map visible)
				}
			}
			
			// 3.1.6] Visualization interface
			
			// SUMMARY:
			// renderMapOverlay_fromPresentation(clusteredMarkers, selectedGeolocations):void
			// renderHeatMapOverlay_fromPresentation(geoArray):void
			// setHeatMapAvailable_fromPresentation(available):void
			// isHeatMapEnabled_fromPresentation:Boolean
			
			// renderMapOverlay - displays the clusters generated by the presentation layer
			//
			// @param clusteredMarkers: 
			// @param selectedGeolocations: if the user has filtered on a marker, the name of the geolocations inside the cluster (else null)
			
			public function renderMapOverlay_fromPresentation( clusteredMarkers:ArrayCollection, selectedGeolocations:HashSet ):void
			{
				//clear previous markers from map when new data is loaded.
				//after making sure it has been initialized				
				clusterMarkers( clusteredMarkers, selectedGeolocations );
				
				if ( _needRecenter )
					recenterMap();
			}
			
			/**
			 * Resets the ignore local filter flag and button
			 */
			public function resetIgnoreLocalFilter():void
			{
				ignoreLocalFilter = false;
				localFilterSettings.toolTip = "Ignore Workspace Filtering - Show All Results";
				localFilterSettings.selected = false;
				localFilterSettings.dispatchEvent( new MouseEvent( MouseEvent.ROLL_OUT ) );
			}
			/** END OVERLAY CODE **/
			
			/**
			 * Resets the sekect region button
			 */
			public function resetSelectRegion():void
			{
				regionSelectToggleButton.toolTip = "Enter region selection mode";
				regionSelectToggleButton.selected = false;
				regionSelectToggleButton.dispatchEvent( new MouseEvent( MouseEvent.ROLL_OUT ) );
			}
			
			public function setHeatMapAvailable_fromPresentation( available:Boolean ):void
			{
				if ( null != _mapResizeTimer )
				{ // (this is one of the last things called when the map is ready)
					_heatMapMiddelay.visible = SHOW_HEAT_MAP && available;
				}
				else
				{
					_nSavedHeatMapState = int( available );
				}
			}
			
			
			/**
			 * @returns A list of supported formats, displayed in a context menu in the format
			 * "Export <string>" - these are called with "generateExportData"
			 * Note this doesn't cover the "built-in" Alive PDF export.
			 * However if the developer specifies PDF and generatePdf() returns non-null then this will be used.
			 */
			
			public function supportedExportFormats():ArrayCollection
			{
				var ac:ArrayCollection = new ArrayCollection();
				ac.addItem( "kml" );
				return ac;
			}
			
			protected function displayTypes_changeHandler( event:IndexChangeEvent ):void
			{
				var displayType:Object = _presentationLayer.getAllowedOntologyTypes().getItemAt( event.newIndex ) as Object;
				displayType.toggled = !displayType.toggled;
				
				//have to redraw data with points changed					
				_presentationLayer.doMapDisplayProcessing();
				
				displayTypes.selectedIndex = -1;
			}
			
			protected function kmlLayers_changeHandler( event:IndexChangeEvent ):void
			{
				//get the layer turned on/off and turn it on/off				
				var kmlOption:Object = kmlLayerNames.getItemAt( event.newIndex ) as Object;
				kmlOption.toggled = !kmlOption.toggled;
				
				if ( SHOW_KML_LAYERS )
				{
					if ( kmlOption.toggled )
					{
						_map.addShapeCollection( kmlCollection.getItemAt( event.newIndex ) as RemoteCollection );
					}
					else
					{
						_map.removeShapeCollection( kmlCollection.getItemAt( event.newIndex ) as RemoteCollection );
					}
				}
				
				kmlLayers.selectedIndex = -1;
			}
			
			protected function ontologyMenuChangeEvent( event:MenuEvent ):void
			{
				//have to redraw data with points changed					
				_presentationLayer.doMapDisplayProcessing();
			}
			
			protected function showOptions_changeHandler( event:IndexChangeEvent ):void
			{
				var showOption:Object = _presentationLayer.getShowOptions().getItemAt( event.newIndex ) as Object;
				showOption.toggled = !showOption.toggled;
				
				switch ( showOption.data )
				{
					case "heatMap":
					{
						SHOW_HEAT_MAP = showOption.toggled;
						_heatMapMiddelay.visible = SHOW_HEAT_MAP;
						_presentationLayer.heatMapRedraw_fromGUI();
						break;
					}
					case "geoDocuments":
					{
						SHOW_GEO_DOCUMENTS = showOption.toggled;
						_presentationLayer.doMapDisplayProcessing();
						break;
					}
					case "geoEntities":
					{
						SHOW_GEO_ENTITIES = showOption.toggled;
						_presentationLayer.doMapDisplayProcessing();
						break;
					}
					case "geoEvents":
					{
						SHOW_GEO_EVENTS = showOption.toggled;
						_presentationLayer.doMapDisplayProcessing();
						break;
					}
					case "kmlLayers":
					{
						SHOW_KML_LAYERS = showOption.toggled;
						displayKMLLayers( SHOW_KML_LAYERS );
						break;
					}
				}
				
				showOptions.selectedIndex = -1;
			}
			
			// Timer to make help disappear
			
			private function _regionTimerTick( event:TimerEvent ):void
			{
				_regionTimer.stop();
				PopUpManager.removePopUp( _regionPopUp );
			}
			
			private function addAllMarkers( markerList:ArrayCollection, maxSize:Number ):void
			{
				for each ( var marker:Object in markerList )
				{
					addMarkers( marker[ "lat" ], marker[ "lon" ], marker[ "size" ], marker[ "alpha" ], marker[ "tooltip" ], marker[ "evtsize" ], maxSize );
				}
			
				// USER OVERLAYS:
			/*if ( ( null != _kmlData ) && ( null != _kmlLoader ) )
			{
				_kmlLoader.loadKML( _kmlData ); // now render the actual local overlays...
			}*/
			}
			
			/**
			 * function to add markers to the map based on lat and lon points
			 *
			 * @param lat The latitude of the point
			 * @param lon The longitude of the point
			 * @param markerSize The number of markers at the cluster
			 */
			private function addMarkers( lat:Number, lon:Number, markerSize:Number, alpha:Number, tooltip:String, eventSize:Number = 0, maxSize:Number = 1 ):void
			{
				var poi:Poi = new Poi( new LatLng( lat, lon ) );
				var icon:MapIcon = new MapIcon();
				icon.setImage( new InfiniteClusterIcons( markerSize.toString(), eventSize, maxSize ) );//, 32, 32, false );
				icon.alpha = alpha;
				poi.icon = icon;
				poi.icon.anchorOffset = new Point( poi.icon.width / 2 * -1, poi.icon.height / 2 * -1 );
				
				
				var text:String;
				
				if ( regionSelectToggleButton.selected )
				{
					text = tooltip + "\n[Mouse: no action, drag to select region as normal]";
				}
				else
				{
					if ( zoomToggleButton.selected )
					{
						text = tooltip + "\n[Mouse: add docs containing selected entities to filter]";
					}
					else
					{
						text = tooltip + "\n[Mouse: zoom to cluster]";
					}
				}
				poi.rolloverContent = text;
				
				// In region select mode, want to treat a marker click exactly like a normal click
				if ( regionSelectToggleButton.selected )
				{
					poi.addEventListener( MouseEvent.MOUSE_MOVE, onMapMoveMouse );
					poi.addEventListener( MouseEvent.MOUSE_DOWN, onMouseDragStart );
					poi.addEventListener( MouseEvent.MOUSE_UP, onMouseDragEnd );
				}
				
				poi.addEventListener( MouseEvent.CLICK, onMarkerClick );
				_map.addShape( poi );
			}
			
			private function addRegionToGeoDecay( event:Event ):void
			{
				var distance:Number = _regionStartLatLng.arcDistance( _regionEndLatLng, DistanceUnits.KILOMETERS );
				_presentationLayer.onUpdateQuery_fromGUI( _regionStartLatLng, distance, false );
				optionPopUpLoseFocus( null );
			}
			
			// Region select options:
			
			private function addRegionToQuery( event:Event ):void
			{
				var distance:Number = _regionStartLatLng.arcDistance( _regionEndLatLng, DistanceUnits.KILOMETERS );
				this.addRegionToQuery_fromPresentation( _regionStartLatLng, distance );
				optionPopUpLoseFocus( null );
			}
			
			private function cancelRegionSelection( event:Event ):void
			{
				optionPopUpLoseFocus( null );
			}
			
			// 3.1.7] Visualization utilities			
			
			/**
			 * function to get clusters to add markers to the map
			 *
			 * @param clusters The array collection of clusters to add to the map
			 * @param selectedGeolocations: if the user has filtered on a marker, the name of the geolocations inside the cluster (else null)
			 */
			private function clusterMarkers( clusters:ArrayCollection, selectedGeolocations:HashSet ):void
			{
				_map.removeShapes();
				var tempMarkerList:ArrayCollection = new ArrayCollection();
				var maxDocCount:Number = 1;
				
				for each ( var group:ArrayCollection in clusters )
				{
					var alpha:Number = 1;
					
					if ( null != selectedGeolocations )
					{
						if ( hasFilter && !ignoreLocalFilter )
							alpha = .5;
					}
					var feedidSet:HashSet = new HashSet();
					var eventCount:Number = 0;
					var entityCount:Number = 0;
					var docGeoCount:Number = 0;
					
					for each ( var geo:Object in group )
					{
						if ( geo.object_type == "entity" )
						{
							if ( !SHOW_GEO_ENTITIES )
								continue;
							entityCount++;
						}
						else if ( geo.object_type == "docgeo" )
						{
							if ( !SHOW_GEO_DOCUMENTS )
								continue;
							docGeoCount++;
						}
						else
						{
							if ( !SHOW_GEO_EVENTS )
								continue;
							eventCount++;
						}
						feedidSet.add( geo.feed );
						
						if ( ( null != selectedGeolocations ) && selectedGeolocations.contains( geo.index ) )
						{
							alpha = 1.0;
						}
					}
					
					if ( 0 == ( entityCount + docGeoCount + eventCount ) )
					{
						continue; // (only display markers containing something)
					}
					var tempMarker:Object = new Object();
					tempMarker[ "lat" ] = group[ 0 ].geotag.lat;
					tempMarker[ "lon" ] = group[ 0 ].geotag.lon;
					tempMarker[ "size" ] = feedidSet.size();
					tempMarker[ "alpha" ] = alpha;
					tempMarker[ "tooltip" ] = "Documents: " + feedidSet.size() + "\nDocument Geotags: " + docGeoCount + "\nGeotags: " + entityCount + "\nEvents: " + eventCount;
					tempMarker[ "evtsize" ] = eventCount;
					tempMarkerList.addItem( tempMarker );
					
					if ( feedidSet.size() > maxDocCount )
						maxDocCount = feedidSet.size();
				}
				addAllMarkers( tempMarkerList, maxDocCount );
			}
			
			private function createKML():ByteArray
			{
				var xml:String = "< xmlns=\"http://www.opengis.net/kml/2.2\"><Document>";
				xml += "<Style id=\"Document\"><IconStyle><Icon><href>http://maps.google.com/mapfiles/kml/pushpin/wht-pushpin.png</href></Icon></IconStyle></Style>";
				xml += "<Style id=\"Entity\"><IconStyle><Icon><href>http://maps.google.com/mapfiles/kml/pushpin/red-pushpin.png</href></Icon></IconStyle></Style>";
				xml += "<Style id=\"Event\"><IconStyle><Icon><href>http://maps.google.com/mapfiles/kml/pushpin/ltblu-pushpin.png</href></Icon></IconStyle></Style>";
				xml += "<Style id=\"DocEnt\"><IconStyle><Icon><href>http://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png</href></Icon></IconStyle></Style>";
				
				//var level:int = 20 - _map.getZoom();
				//var range:int = Math.round(Math.pow(2 ,level) * Math.sqrt((_map.width * _map.width) + (_map.height * _map.height)) / 3.3);
				var snip:Number = 26 - _map.zoom * Math.log( 2 );
				var range:int = Math.round( Math.pow( 2, snip ) );
				//				var zoom:int = zoom = Math.round(26-(Math.log(range)/Math.log(2)));
				xml += "<LookAt><longitude>" + _map.center.lng + "</longitude><latitude>" + _map.center.lat + "</latitude><range>" + range + "</range><tilt>0</tilt></LookAt>";
				
				var feedData:ArrayCollection = _context.getQuery_TopResults().getTopDocuments();
				
				var entityKml:String = "";
				var eventKml:String = "";
				var docKml:String = "";
				var docEntKml:String = "";
				
				for each ( var feed:Object in feedData )
				{
					//loop through the feed to get its entities
					
					for each ( var entity:Object in feed.entities )
					{
						//check to make sure the entity has geotags 
						if ( entity.geotag != null )
						{
							var commonString:String = "<p><b>Entity Type:</b> " + entity.type + "</p>";
							commonString += "<p><b>Document Significance:</b> " + Math.round( Number( entity.significance ) ) + "%</p>";
							commonString += "<p><b>Query Significance:</b> " + Math.round( Number( entity.datasetSignificance ) ) + "%</p>";
							commonString += "<p><b>Relevance:</b> " + ( Math.round( Number( entity.relevance ) * 100 ) ).toPrecision( 2 ) + "%</p>";
							commonString += "<p><b>Frequency:</b> " + entity.frequency + "</p>";
							
							if ( feed.url.substr( 0, 5 ) == "http:" )
							{
								commonString += "<p><b>Url: <b/>" + feed.url + "</p>";
							}
							
							var entVis:String = "";
							
							if ( !SHOW_GEO_ENTITIES )
							{
								entVis += "<visibility>0</visibility>";
							}
							
							
							var entDesc:String = "<![CDATA[";
							entDesc += "<p><b>Feed: " + feed.title + "</b></p>";
							entDesc += commonString;
							entDesc += "\]\]>";
							
							var docEntDesc:String = "<![CDATA[";
							docEntDesc += "<p><b>Entity:</b> " + entity.disambiguated_name + "</p>";
							docEntDesc += commonString;
							docEntDesc += "\]\]>";
							
							
							entityKml += "<Placemark>" + entVis + "<name>Entity: " + entity.disambiguated_name + "</name><description>" + entDesc + "</description><styleUrl>#Entity</styleUrl>" + "<Point><coordinates>" + entity.geotag.lon + "," + entity.geotag.lat + ",0" + "</coordinates></Point></Placemark>";
							docEntKml += "<Placemark>" + entVis + "<name>" + feed.title + "</name><description>" + docEntDesc + "</description><styleUrl>#DocEnt</styleUrl>" + "<Point><coordinates>" + entity.geotag.lon + "," + entity.geotag.lat + ",0" + "</coordinates></Point></Placemark>";
						}
					}
					
					//loop through the feed to get its events
					for each ( var event:Object in feed.associations )
					{
						//check to make sure the event has geotags
						if ( event.geotag != null )
						{
							
							var eventDesc:String = "<![CDATA[";
							
							eventDesc += "<p><b>Feed: </b>" + feed.title + "</p>";
							
							if ( event.entity1 != null )
							{
								eventDesc += "<p><b>Entity 1:</b> " + event.entity1 + "</p>";
							}
							
							if ( event.verb != null )
							{
								eventDesc += "<p><b>Verb:</b> " + event.verb + "</p>";
							}
							
							if ( event.entity2 != null )
							{
								eventDesc += "<p><b>Entity 2:</b> " + event.entity2 + "</p>";
							}
							
							var time:String = "";
							
							if ( event.geotag.time_start != null )
							{
								eventDesc += "<p><b>Time Start:</b>" + event.geotag.time_start + "</p>";
								time += "<TimeStamp>" + event.geotag.time_start + "</TimeStamp>";
							}
							
							eventDesc += "\]\]>";
							
							var evtVis:String = "";
							
							if ( !SHOW_GEO_EVENTS )
							{
								evtVis += "<visibility>0</visibility>";
							}
							
							eventKml += "<Placemark>" + evtVis + "<name>Event: " + event.verb_category + "</name>" + time + "<description>" + eventDesc + "</description><styleUrl>#Event</styleUrl>" + "<Point><coordinates>" + event.geotag.lon + "," + event.geotag.lat + ",0" + "</coordinates></Point></Placemark>";
							
						}
					}
					
					//get a documents docgeo if it exists
					if ( feed.docGeo != null )
					{
						var docDesc:String = "<![CDATA[";
						
						docDesc += "<p><b>Description: </b>" + feed.description + "</p>";
						
						if ( feed.url.substr( 0, 5 ) == "http:" )
						{
							docDesc += "<p><b>Url: </b>" + feed.url + "</p>";
						}
						
						docDesc += "\]\]>";
						
						var docVis:String = "";
						
						if ( !SHOW_GEO_DOCUMENTS )
						{
							docVis += "<visibility>0</visibility>";
						}
						
						docKml += "<Placemark>" + docVis + "<name>" + feed.title + "</name><description>" + docDesc + "</description><styleUrl>#Document</styleUrl>" + "<Point><coordinates>" + feed.docGeo.lon + "," + feed.docGeo.lat + ",0" + "</coordinates></Point></Placemark>";
					}
				}
				
				
				
				xml += "<Folder><name>Geo-tagged Entities</name>";
				
				if ( !SHOW_GEO_ENTITIES )
				{
					xml += "<visibility>0</visibility>";
				}
				xml += entityKml;
				xml += "</Folder>";
				
				xml += "<Folder><name>Geo-tagged Documents</name>";
				
				if ( !SHOW_GEO_DOCUMENTS )
				{
					xml += "<visibility>0</visibility>";
				}
				xml += docKml;
				xml += "</Folder>";
				
				xml += "<Folder><name>Geo-tagged Events</name>";
				
				if ( !SHOW_GEO_EVENTS )
				{
					xml += "<visibility>0</visibility>";
				}
				xml += eventKml;
				xml += "</Folder>";
				
				xml += "<Folder><name>Documents Containing Geo-tagged Entities</name>";
				xml += docEntKml;
				xml += "</Folder>";
				
				xml += "</Document></kml>";
				
				var x:XML = new XML( xml );
				
				var ba:ByteArray = new ByteArray();
				ba.writeUTFBytes( x );
				return ba;
			
			}
			
			private function displayKMLLayers( show:Boolean ):void
			{
				for ( var i:int = 0; i < kmlLayerNames.length; i++ )
				{
					var layerToggle:Object = kmlLayerNames.getItemAt( i );
					
					if ( show && layerToggle.toggled )
						_map.addShapeCollection( kmlCollection.getItemAt( i ) as RemoteCollection );
					else
						_map.removeShapeCollection( kmlCollection.getItemAt( i ) as RemoteCollection );
				}
			}
			
			private function doneResizingMap( event:TimerEvent ):void
			{
				if ( SHOW_HEAT_MAP )
				{
					_heatMapMiddelay.visible = true; // (otherwise isHeatMapEnabled returns false)
					
					// For some reason call entire procesing after map finished moving, only heat map after resize?
					_presentationLayer.heatMapRedraw_fromGUI();
				}
			}
			
			/**
			 * Helper function for kmlLoaded(), checks if a layers name was in the
			 * widget save options.  If it was that means a user previously had
			 * this layer turned on and we should turn it on.  Otherwise it was not
			 * on so we set it to false.
			 */
			private function getKMLLayerWasToggled( newLayerName:String ):Boolean
			{
				if ( this.widgetOptions.openKMLLayers != null )
				{
					var openKMLLayers:Array = this.widgetOptions.openKMLLayers;
					
					for each ( var layer:String in openKMLLayers )
					{
						if ( layer == newLayerName )
							return true;
					}
				}
				else
				{
					//if there was no save, we'll just turn on all the kml
					return true;
				}
				//if we dont find the layer, we'll assume it was turned off
				return false;
			}
			
			/**
			 * Gets the communities name and returns a string of the combined
			 * kml name | community name
			 *
			 * I'm not sure if you can actually get the communities without
			 * calling api calls which seems like overkill at this moment, will leave blank
			 * currently.
			 */
			private function getKmlName( commID:String, kmlName:String ):String
			{
				var returnString:String = kmlName + " | " + commID;
				return returnString;
			}
			
			private function kmlFailed( event:Event ):void
			{
				var target:RemoteCollection = event.target as RemoteCollection;
				trace( "Loading KML: " + target.name + " failed to init" );
			}
			
			/**
			 * Callback function for loading remote kml into the collection called
			 * from onLoadWidgetOptions.  Will put any loaded collections into
			 * the kmlCollection so that it can be loaded on the map and turned on/off
			 * at will.
			 */
			private function kmlLoaded( event:Event ):void
			{
				var target:RemoteCollection = event.target as RemoteCollection;
				kmlCollection.addItem( target );
				var layerToggled:Boolean = getKMLLayerWasToggled( target.name );
				kmlLayerNames.addItem( { label: target.name, data: target.name, type: "check", toggled: layerToggled } );
				
				//if kml is turned on, add this to the map now, otherwise just
				//store it.
				if ( SHOW_KML_LAYERS && layerToggled )
				{
					_map.addShapeCollection( target );
				}
			}
			
			/**
			 * Callback to handle the "ignore/allow" local filter button getting pressed
			 */
			private function onClickIgnoreLocalFilter():void
			{
				internalFilterUpdate = true;
				
				this.ignoreLocalFilter = !this.ignoreLocalFilter;
				
				if ( !this.ignoreLocalFilter )
				{
					localFilterSettings.toolTip = "Ignore Workspace Filtering - Show All Results";
					_presentationLayer.toggleFilter_fromGUI( hasFilter );
				}
				else
				{
					localFilterSettings.toolTip = "Apply Workspace Filtering - Show Filtered Results";
					_presentationLayer.toggleFilter_fromGUI( false );
				}
				
				internalFilterUpdate = false;
			}
			
			private function onMapFinishedMoving( event:Event ):void
			{
				if ( SHOW_HEAT_MAP )
				{
					_heatMapMiddelay.visible = true; // (otherwise isHeatMapEnabled returns false)
				}
				// For some reason call entire procesing after map finished moving, only heat map after resize?
				_presentationLayer.onMapSizeChanged_fromGUI( _map.boundsLL as RectLL, _map.zoom, _map );
				
				_regionSelectMarker = null; // (on zoom, remove the region select marker)
			}
			
			private function onMapMoveMouse( event:MouseEvent ):void
			{
				if ( _regionRadiusDrag )
				{
					if ( _regionSelectRadius != null )
					{
						_map.removeShape( _regionSelectRadius );
						_regionSelectRadius = null;
					}
					/*var polyOptions:PolygonOptions = new PolygonOptions();
					polyOptions.strokeStyle = new StrokeStyle( { color: 0xFF0000 } );
					polyOptions.fillStyle = new FillStyle( { color: 0xCCCCCC, alpha: 0.5 } );
					
					var polyArray:Array = new Array();*/
					
					// (need to save this here since onMouseDragEnd can be the wrong lat/long if generated from marker)
					_regionEndLatLng = _map.pixToLL( new Point( _map.mouseX, _map.mouseY ) );
					
					//create an array of 40 points to create a circle around the
					//start point for region
					/*var distance:Number = _regionStartLatLng.distanceFrom( event.latLng );
					var circlePoints:Number = 40;
					var circleLat:Number = ( distance / 1000 ) * 0.621371192 * 0.014483;
					var circleLng:Number = circleLat / Math.cos( _regionStartLatLng.lat() * ( Math.PI / 180 ) );
					
					for ( var i:int = 0; i < circlePoints; i++ )
					{
						var theta:Number = Math.PI * ( ( 2 * i ) / circlePoints );
						var pointLat:Number = _regionStartLatLng.lat() + ( circleLat * Math.sin( theta ) );
						var pointLng:Number = _regionStartLatLng.lng() + ( circleLng * Math.cos( theta ) );
						polyArray.push( new LatLng( pointLat, pointLng, true ) );
					}*/
					
					var distance:Number = _regionStartLatLng.arcDistance( _regionEndLatLng );
					_regionSelectRadius = new CircleOverlay();
					var circlePoints:LatLngCollection = new LatLngCollection();
					circlePoints.add( _regionStartLatLng );
					_regionSelectRadius.shapePoints = circlePoints;
					_regionSelectRadius.radius = distance;
					_regionSelectRadius.borderWidth = 1;
					_regionSelectRadius.fillColor = 0xCCCCCC;
					_regionSelectRadius.fillColorAlpha = .5;
					_regionSelectRadius.color = 0xFF0000;
					_regionSelectRadius.colorAlpha = 1;
					_map.addShape( _regionSelectRadius );
				}
			}
			
			/**
			 * Callback to initialize the map variables when it's done loading
			 *
			 * @param event The Event received when the map is ready
			 */
			private function onMapReady( event:Event ):void
			{
				// Map specific code:
				this._map.setCenter( new LatLng( 20.676362, 5.992188 ), 3 );
				this._map.addControl( new SMLargeZoomControl() );
				this._map.addControl( new MouseWheelZoomControl() );
				
				// Handle map movement
				this._map.addEventListener( TileMapEvent.MOVE_START, onMapStartedMoving );
				this._map.addEventListener( TileMapEvent.MOVE_END, onMapFinishedMoving );
				this._map.addEventListener( TileMapEvent.ZOOM_END, onMapFinishedMoving );
				//this._map.addEventListener( Event.RESIZE, onMapFinishedMoving );
				this.addEventListener( ResizeEvent.RESIZE, onMapFinishedMoving );
				
				// Handle region selection
				this._map.addEventListener( MouseEvent.MOUSE_MOVE, onMapMoveMouse );
				this._map.addEventListener( MouseEvent.MOUSE_DOWN, onMouseDragStart );
				this._map.addEventListener( MouseEvent.MOUSE_UP, onMouseDragEnd );
				
				this._map.enabled = true;
				this._map.visible = true;
				rolloverWindow = new InfininiteRollover( _map.tileMap );
				_map.rolloverWindow = rolloverWindow;
				
				// Timer for heatmap optimization
				_mapResizeTimer = new Timer( 100, 1 ); // (runs once after 100ms)
				_mapResizeTimer.addEventListener( TimerEvent.TIMER_COMPLETE, doneResizingMap );
				
				// Let the presentation layer know the bounds
				
				_presentationLayer.onMapSizeChanged_fromGUI( _map.boundsLL as RectLL, _map.zoom, _map );
			}
			/**
			 * Callback to handle the user stopping dragging the mouse (or zooming??)
			 */
			private function onMapStartedMoving( event:Event ):void
			{
				_heatMapMiddelay.visible = false;
				
				//clear any region selecting
				if ( _regionSelectMarker != null )
					_map.removeShape( _regionSelectMarker );
				
				if ( _regionSelectRadius != null )
					_map.removeShape( _regionSelectRadius );
				_regionSelectRadius = null;
				_regionSelectMarker = null;
				_regionRadiusSelect = false;
				
				// (cancel regions select mode if enabled)
				if ( regionSelectToggleButton.selected )
				{ //first click set marker and await drag end
					optionPopUpLoseFocus( null );
				}
			}
			
			/**
			 * Callback to handle the user clicking on the map
			 * (currently: ignore unless it hits a marker)
			 */
			private function onMarkerClick( event:MouseEvent ):void
			{
				var poi:Poi = event.currentTarget as Poi;
				
				// Not if in region selection code
				if ( !regionSelectToggleButton.selected )
				{
					if ( !zoomToggleButton.selected )
					{
						_presentationLayer.onZoomToCluster_fromGUI( poi.latLng.lat, poi.latLng.lng );
					}
					else
					{
						_presentationLayer.onFilterClusterFromLatLong_fromGUI( poi.latLng.lat, poi.latLng.lng );
					}
				}
			}
			
			private function onMouseDragEnd( event:MouseEvent ):void
			{
				if ( _regionRadiusSelect ) //if we are done dragging out a region
				{
					_mouseEnd = new Point( _map.mouseX, _map.mouseY );
					
					if ( ( Math.abs( _mouseEnd.x - _mouseStart.x ) > 5 ) || ( Math.abs( _mouseEnd.y - _mouseStart.y ) > 5 ) )
					{
						//prompt user on what they want to do with region:
						_regionRadiusSelect = false;
						_regionRadiusDrag = false;
						showRegionOptionsPopUp();
					}
					else //was a click event, so restart marker drag
					{
						if ( null != _regionSelectMarker )
							_map.removeShape( _regionSelectMarker );
						_regionRadiusDrag = false;
						
						if ( _regionSelectRadius != null )
						{
							_map.removeShape( _regionSelectRadius );
							_regionSelectRadius = null;
						}
					}
				}
			}
			
			// Dragging in region select mode
			
			private function onMouseDragStart( event:MouseEvent ):void
			{
				if ( _regionRadiusSelect ) //first click set marker and await drag end
				{
					_mouseStart = new Point( _map.mouseX, _map.mouseY );
					_map.setFocus();
					
					if ( null != _regionSelectMarker )
						_map.removeShape( _regionSelectMarker );
					
					if ( _regionSelectRadius != null )
					{
						_map.removeShape( _regionSelectRadius );
						_regionSelectRadius = null;
					}
					_regionStartLatLng = _map.pixToLL( new Point( _map.mouseX, _map.mouseY ) );
					_regionSelectMarker = new Poi( _regionStartLatLng );
					_map.addShape( _regionSelectMarker );
					_regionRadiusDrag = true;
				}
			}
			
			// 3.1.5] Callbacks
			
			/**
			 * Method fired when module is done loading.  Sends
			 * message to parent letting it know that module is
			 * ready to receive data.
			 */
			private function onWidgetCreationComplete():void
			{
				onMapReady( null );
			}
			
			// Handles selecting an option
			
			private function optionPopUpLoseFocus( event:FlexMouseEvent ):void
			{
				if ( _regionPopUp != null )
					PopUpManager.removePopUp( _regionPopUp );
				
				if ( _regionOptionPopUp != null )
				{
					_regionOptionPopUp.removeEventListener( FlexMouseEvent.MOUSE_DOWN_OUTSIDE, optionPopUpLoseFocus );
					PopUpManager.removePopUp( _regionOptionPopUp );
				}
				
				if ( event == null || event.relatedObject != regionSelectToggleButton )
				{
					resetSelectRegion();
					regionSelectToggleButton_changeHandler();
					_map.draggable = true;
				}
			}
			
			/**
			 * Callback to handle the user clicking on the map
			 * Note contained in this viz layer, since it's just a GUI function
			 *
			 * @param event The IndexChangeEvent received when a map type is selected on the tabbar
			 */
			private function overlayOptions_changeHandler( event:IndexChangeEvent ):void
			{
				if ( event.newIndex == MAP_OVERLAY )
				{
					_map.mapType = "map";
				}
				
				if ( event.newIndex == SATTELITE_OVERLAY )
				{
					_map.mapType = "sat";
				}
				
				if ( event.newIndex == HYBRID_OVERLAY )
				{
					_map.mapType = "hyb";
				}
			}
			
			private function recenterMap():void
			{
				if ( _mapMarkerBounds != null )
				{
					_needRecenter = false;
					
					if ( widgetOptions != null )
					{
						_map.setCenter( new LatLng( widgetOptions.centerLat, widgetOptions.centerLng ), widgetOptions.zoomLevel );
						widgetOptions = null;
					}
					else
					{
						_map.zoomToRect( _mapMarkerBounds );
						
					}
				}
			}
			/**
			 * Callback to start/stop region selection mode
			 */
			private function regionSelectToggleButton_changeHandler( event:Event = null ):void
			{
				if ( !regionSelectToggleButton.selected )
				{ // Leaving region selection mode
					
					_map.draggable = true;
					regionSelectToggleButton.toolTip = "Enter region selection mode";
					
					if ( _regionSelectMarker != null )
						_map.removeShape( _regionSelectMarker );
					
					if ( _regionSelectRadius != null )
						_map.removeShape( _regionSelectRadius );
					
					_regionSelectRadius = null;
					_regionSelectMarker = null;
					_regionRadiusSelect = false;
				}
				else
				{ // Entering region selection mode
					regionSelectToggleButton.toolTip = "Leave region selection mode (will lose any selected regions)";
					//display message prompting user to click/drag
					showRegionSelectPopUp();
					_regionRadiusSelect = true;
					
					_map.draggable = false;
				}
				// Redraw the clusters with clickability on/off
				_presentationLayer.doMapDisplayProcessing();
			}
			
			private function resetKMLCollections():void
			{
				for each ( var remoteColl:RemoteCollection in kmlCollection )
				{
					_map.removeShapeCollection( remoteColl );
				}
				remoteCollection.removeAll();
				kmlCollection.removeAll();
				kmlLayerNames.removeAll();
			}
			
			// (options)
			
			private function showRegionOptionsPopUp():void
			{
				//create it
				if ( _regionOptionPopUp == null )
				{
					var sepVGroup1:VGroup = new VGroup();
					sepVGroup1.horizontalAlign = "center";
					sepVGroup1.verticalAlign = "middle";
					sepVGroup1.percentHeight = 100;
					sepVGroup1.percentWidth = 100;
					var seperator1:Line = new Line();
					seperator1.percentWidth = 90;
					seperator1.yFrom = 1;
					seperator1.yTo = 1;
					seperator1.stroke = new SolidColorStroke( 0xBBBBBB, 1 );
					sepVGroup1.addElement( seperator1 );
					
					var sepVGroup2:VGroup = new VGroup();
					sepVGroup2.horizontalAlign = "center";
					sepVGroup2.verticalAlign = "middle";
					sepVGroup2.percentHeight = 100;
					sepVGroup2.percentWidth = 100;
					var seperator2:Line = new Line();
					seperator2.percentWidth = 90;
					seperator2.yFrom = 1;
					seperator2.yTo = 1;
					seperator2.stroke = new SolidColorStroke( 0xBBBBBB, 1 );
					sepVGroup2.addElement( seperator2 );
					
					var link1:LinkButton = new LinkButton();
					link1.label = "Add region to query";
					link1.addEventListener( "click", addRegionToQuery );
					
					var link2:LinkButton = new LinkButton();
					link2.label = "Set region as geo decay";
					link2.addEventListener( "click", addRegionToGeoDecay );
					
					var link3:LinkButton = new LinkButton();
					link3.label = "Zoom to region";
					link3.addEventListener( "click", zoomToRegion );
					
					var linkCancel:LinkButton = new LinkButton();
					linkCancel.label = "Cancel region selection";
					linkCancel.addEventListener( "click", cancelRegionSelection );
					
					var vg:VGroup = new VGroup();
					vg.verticalAlign = "middle";
					vg.horizontalAlign = "left";
					vg.percentHeight = 100;
					vg.percentWidth = 100;
					vg.addElement( link1 );
					vg.addElement( link2 );
					vg.addElement( sepVGroup1 );
					vg.addElement( link3 );
					vg.addElement( sepVGroup2 );
					vg.addElement( linkCancel );
					_regionOptionPopUp = new BorderContainer();
					_regionOptionPopUp.alpha = 1;
					_regionOptionPopUp.setStyle( "paddingBottom", 2 );
					_regionOptionPopUp.setStyle( "paddingTop", 2 );
					_regionOptionPopUp.setStyle( "paddingLeft", 2 );
					_regionOptionPopUp.setStyle( "paddingRight", 2 );
					_regionOptionPopUp.setStyle( "backgroundColor", 0xEEEEEE );
					_regionOptionPopUp.setStyle( "cornerRadius", 5 );
					_regionOptionPopUp.percentWidth = 100;
					_regionOptionPopUp.percentHeight = 100;
					_regionOptionPopUp.addElement( vg );
				}
				//then show it
				var popupX:int = this.parent.parent.hasOwnProperty( "title" ) ? this.parent.parent.x : this.parent.parent.parent.x;
				var popupY:int = this.parent.parent.hasOwnProperty( "title" ) ? this.parent.parent.y : this.parent.parent.parent.y + 60;
				_regionOptionPopUp.x = popupX + _mouseEnd.x;
				_regionOptionPopUp.y = popupY + _mouseEnd.y;
				
				// (remove other popup)
				if ( _regionPopUp != null )
					PopUpManager.removePopUp( _regionPopUp );
				
				// show this pop up
				PopUpManager.removePopUp( _regionOptionPopUp );
				PopUpManager.addPopUp( _regionOptionPopUp, this, false );
				PopUpManager.bringToFront( _regionOptionPopUp );
				
				_regionOptionPopUp.setFocus();
				_regionOptionPopUp.addEventListener( FlexMouseEvent.MOUSE_DOWN_OUTSIDE, optionPopUpLoseFocus );
			}
			
			//
			// Lots of region selection logic:
			//
			
			// Pop ups
			
			// (help)
			
			private function showRegionSelectPopUp():void
			{
				//create the popup if needbe
				if ( _regionPopUp == null )
				{
					var label:Label = new Label();
					label.text = "Click a location and drag to select a region";
					var hg:HGroup = new HGroup();
					hg.verticalAlign = "middle";
					hg.horizontalAlign = "center";
					hg.percentHeight = 100;
					hg.percentWidth = 100;
					hg.addElement( label );
					_regionPopUp = new BorderContainer();
					_regionPopUp.alpha = 1;
					_regionPopUp.setStyle( "paddingBottom", 2 );
					_regionPopUp.setStyle( "paddingTop", 2 );
					_regionPopUp.setStyle( "paddingLeft", 2 );
					_regionPopUp.setStyle( "paddingRight", 2 );
					_regionPopUp.setStyle( "backgroundColor", 0xEEEEEE );
					_regionPopUp.setStyle( "cornerRadius", 5 );
					_regionPopUp.width = 320;
					_regionPopUp.height = 40;
					_regionPopUp.addElement( hg );
					
					_regionTimer = new Timer( 4000 );
					_regionTimer.addEventListener( TimerEvent.TIMER, _regionTimerTick );
				}
				
				//then show it
				PopUpManager.removePopUp( _regionPopUp );
				PopUpManager.addPopUp( _regionPopUp, this, false );
				PopUpManager.centerPopUp( _regionPopUp );
				_regionTimer.stop();
				_regionTimer.start();
			}
			
			private function zoomToRegion( event:Event ):void
			{
				optionPopUpLoseFocus( null );
				
				var distance:Number = _regionStartLatLng.arcDistance( _regionEndLatLng, DistanceUnits.KILOMETERS );
				var circleLat:Number = ( distance ) * 0.621371192 * 0.014483;
				var circleLng:Number = circleLat / Math.cos( _regionStartLatLng.lat * ( Math.PI / 180 ) );
				var theta:Number = Math.PI / 4;
				//CALC NE Point (45 degrees i.e. pi/4
				
				var nepointLat:Number = _regionStartLatLng.lat + ( circleLat * Math.sin( theta ) );
				var nepointLng:Number = _regionStartLatLng.lng + ( circleLng * Math.cos( theta ) );
				
				//CALC SW Point (5pi/4)
				theta = 5 * Math.PI / 4;
				var swpointLat:Number = _regionStartLatLng.lat + ( circleLat * Math.sin( theta ) );
				var swpointLng:Number = _regionStartLatLng.lng + ( circleLng * Math.cos( theta ) );
				
				//create bounds from points and zoom to that
				//(NORTH WEST) AND (SOUTH EAST)
				var bounds:RectLL = new RectLL( new LatLng( nepointLat, swpointLng ), new LatLng( swpointLat, nepointLng ) );
				_map.zoomToRect( bounds );
			}
			
			// Other callback code
			
			private function zoomToggleButton_changeHandler( event:Event ):void
			{
				if ( zoomToggleButton.selected )
				{
					zoomToggleButton.toolTip = "Enter click-to-zoom mode/leave click-to-filter mode (and re-enable auto-zoom)";
				}
				else
				{
					zoomToggleButton.toolTip = "Enter click-to-filter mode/leave click-to-zoom mode (and disable auto-zoom)";
				}
				// Redraw the clusters with a new tooltip
				_presentationLayer.doMapDisplayProcessing();
			}
		]]>
	</fx:Script>
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>

	<!-- If you would like this widget to be styled similar to the other infinite widgets
		you may place items in the headerContent section shown below and they will be drawn at
		the top of the widget.  If you want to use similar looking buttons explore the
		com.ikanow.infinit.e.widget.library.components.* items looking for components
		prefixed with Widget*.  Other components may be added to the header as well.
	-->
	<components:headerContent>
		<s:HGroup gap="-3">

			<!-- Ignore Filter Toggle Button -->
			<components:WidgetIgnoreFilterToggleButton id="localFilterSettings"
				toolTip="Ignore Workspace Filtering - Show All Results"
				click="setTimeout( onClickIgnoreLocalFilter, 100 )" />

			<!-- Zoom Toggle Button -->
			<components:WidgetZoomToggleButton id="zoomToggleButton"
				toolTip="Enter click-to-filter mode/leave click-to-zoom mode (and disable auto-zoom)"
				change="zoomToggleButton_changeHandler(event)" />

			<!-- Region Select Toggle Button -->
			<components:WidgetRegionSelectToggleButton id="regionSelectToggleButton"
				toolTip="Enter region selection mode"
				change="regionSelectToggleButton_changeHandler(event)" />

			<!-- Map Overlays Drop Down List -->
			<components:WidgetPromptDropDownList id="overlayOptions"
				width="95"
				selectedIndex="{ MAP_OVERLAY }"
				change="setTimeout( overlayOptions_changeHandler, 100, event )"
				listWidth="93"
				prompt="Overlays">
				<components:dataProvider>
					<s:ArrayList source="[Map,Satellite]" />
				</components:dataProvider>
			</components:WidgetPromptDropDownList>

			<!-- Show Options Drop Down List -->
			<components:WidgetPromptCheckBoxDropDownList id="showOptions"
				width="76"
				selectedIndex="-1"
				dataProvider="{ _presentationLayer.getShowOptions() }"
				change="setTimeout( showOptions_changeHandler, 100, event )"
				listWidth="190"
				prompt="Show" />

			<!-- Display Types Drop Down List -->
			<components:WidgetPromptCheckBoxDropDownList id="displayTypes"
				width="125"
				selectedIndex="-1"
				dataProvider="{ _presentationLayer.getAllowedOntologyTypes() }"
				change="setTimeout( displayTypes_changeHandler, 100, event )"
				listWidth="170"
				prompt="Display Types" />

			<!-- Display Types Drop Down List -->
			<components:WidgetPromptCheckBoxDropDownList id="kmlLayers"
				width="125"
				selectedIndex="-1"
				dataProvider="{ kmlLayerNames }"
				change="setTimeout( kmlLayers_changeHandler, 100, event )"
				listWidth="170"
				prompt="KML Layers" />

		</s:HGroup>
	</components:headerContent>

	<s:HGroup 
		width="100%"
		height="100%">
		<s:Group id="_mapgroup"
			width="100%"
			height="100%"
			x="0"
			y="0">

			<!-- Heatmap -->
			<ilog:DensityHeatMap id="_heatMapMiddelay"
				width="100%"
				height="100%"
				dataProvider="{ _heatMapData }"
				alpha="0.75"
				depth="1"
				mouseEnabled="false"
				pointSize="30"
				pointValue="10">
				<ilog:colorModel>
					<ilog:ColorModel>
						<ilog:ColorEntry 
							color="0x0000ff"
							alpha="0"
							limit="0" />
						<ilog:ColorEntry 
							color="0x00ff00"
							limit="50" />
						<ilog:ColorEntry 
							color="0xff0000"
							alpha="1"
							limit="100" />
					</ilog:ColorModel>
				</ilog:colorModel>
			</ilog:DensityHeatMap>

			<!-- Map -->
			<tilemap:TilemapComponent id="_map"
				x="0"
				y="0"
				width="100%"
				height="100%"
				key="{ API_KEY }"
				zoom="4" />
		</s:Group>
	</s:HGroup>
	<fx:Script source="com/ikanow/infinit/e/actionscript/InfiniteMapModelLayer.as" />
</components:WidgetModule>
